# 类的拷贝控制
## 构造函数、拷贝函数 、 赋值函数、析构函数
      class Sales_data{
      public:
        Sales_data() = default;// 默认合成 默认构造函数
        Sales_data(const Sales_data& ) =  default;// 默认合成 拷贝构造函数
        Sales_data& operator=(const Sales_data&);//  拷贝赋值运算符
        ~Sales_data() = default;// 默认合成 默认析构函数
      };
       Sales_data&  Sales_data::operator=(const Sales_data&) = default;//  拷贝赋值运算符 类外定义
 ## 使用 delete 删除函数 避免拷贝
       struct NoCopy(){// struct 默认为 public
       NoCopy() = default;//  默认合成 默认构造函数    不能是删除函数
       NoCopy(const NoCopy&) = delete;// 阻止拷贝
       NoCopy&  operator=(const NoCopy&);//  阻止赋值
       ~NoCopy() = default;// 默认合成 默认析构函数   不能是删除函数
       };

## private 拷贝控制  用户可定义和删除该对象 但不能拷贝它们   不过该类的成员函数 和其 有元函数和有元类 可以 拷贝
      class privateCopy{// class 默认为 private  普通用户无法访问
        privateCopy(const privateCopy&);// 私有拷贝构造函数
        privateCopy& operator=(const privateCopy&);// 私有拷贝赋值运算符
      public:
        privateCopy() = default; // 默认合成  默认构造函数
        ~privateCopy() = default;// 默认合成 默认析构函数   不能是删除函数
      }

# 重载
## 重载输出运算符 <<  为特定类对象 重载输出运算符 返回的是 ostream& 输出流对象的引用
    // 一般定义成 非成员函数 在{};外面
     ostream& operator<<(ostream& os, const Sales_data& item ){
       os << item.isbn() << " " << item.units_sold << " " << item.revenue << " " << item.avg_price();
       // 使用了 字符串的、int、double的 输出运算符 类构成类的 输出运算符
       return os;
     }
## 重载 输入 运算符 >>  返回的是  istream& 输入流对象的引用
      istream& operator>>(istream& is, const Sales_data& item ){
      double price;// 单价
      is >> item.bookNo >> item.units_sold >> price;
      if(is)//检测输入是否成功
        item.revenue = item.units_sold * price
      else
        item = Sales_data();//输入失败，对象呗赋予默认的状态
        return is;
      }
## 重载 关系运算符  ==  不等于也类似 !=
    // 关系运算符  返回类型为 bool  输入两个类对象的 常量 引用 避免拷贝 节省时间 常量限制 避免修改 
    bool 
    operator==(const Sales_item &lhs, const Sales_item &rhs)
    {
        // 在类中被是定义为 friend 有元函数 
        // friend bool operator==(const Sales_item&, const Sales_item&);// 重定向 等于符号 == 
        return lhs.units_sold == rhs.units_sold &&
               lhs.revenue == rhs.revenue &&
               lhs.isbn() == rhs.isbn();
    }
## 整体 浏览

        #ifndef SALESITEM_H
        // we're here only if SALESITEM_H has not yet been defined 
        #define SALESITEM_H

        // Definition of Sales_item class and related functions goes here
        #include <iostream>
        #include <string>

        class Sales_item {
        // these declarations are explained section 7.2.1, p. 270 
        // and in chapter 14, pages 557, 558, 561
        // 操作符 定义
        friend std::istream& operator>>(std::istream&, Sales_item&);// 重定向输入 >> 符号
        friend std::ostream& operator<<(std::ostream&, const Sales_item&);// 重定向输出 << 符号
        friend bool operator<(const Sales_item&, const Sales_item&);// 重定向 小于符号 < 
        friend bool operator==(const Sales_item&, const Sales_item&);// 重定向 等于符号 ==  
        public:
            // constructors are explained in section 7.1.4, pages 262 - 265
            // default constructor needed to initialize members of built-in type
            Sales_item() = default;
            Sales_item(const std::string &book): bookNo(book) { }
            Sales_item(std::istream &is) { is >> *this; }
        public:
            // operations on Sales_item objects
            // member binary operator: left-hand operand bound to implicit this pointer
            Sales_item& operator+=(const Sales_item&);

            // operations on Sales_item objects
            std::string isbn() const { return bookNo; }
            double avg_price() const;
        // private members as before
        private:
            std::string bookNo;      // implicitly initialized to the empty string
            unsigned units_sold = 0; // explicitly initialized
            double revenue = 0.0;
        };

        // used in chapter 10
        inline
        bool compareIsbn(const Sales_item &lhs, const Sales_item &rhs) 
        { return lhs.isbn() == rhs.isbn(); }

        // nonmember binary operator: must declare a parameter for each operand
        Sales_item operator+(const Sales_item&, const Sales_item&);

        inline bool 
        operator==(const Sales_item &lhs, const Sales_item &rhs)
        {
            // must be made a friend of Sales_item
            return lhs.units_sold == rhs.units_sold &&
                   lhs.revenue == rhs.revenue &&
                   lhs.isbn() == rhs.isbn();
        }

        inline bool 
        operator!=(const Sales_item &lhs, const Sales_item &rhs)
        {
            return !(lhs == rhs); // != defined in terms of operator==
        }

        // assumes that both objects refer to the same ISBN
        Sales_item& Sales_item::operator+=(const Sales_item& rhs) 
        {
            units_sold += rhs.units_sold; 
            revenue += rhs.revenue; 
            return *this;
        }

        // assumes that both objects refer to the same ISBN
        Sales_item 
        operator+(const Sales_item& lhs, const Sales_item& rhs) 
        {
            Sales_item ret(lhs);  // copy (|lhs|) into a local object that we'll return
            ret += rhs;           // add in the contents of (|rhs|) 
            return ret;           // return (|ret|) by value
        }

        std::istream& 
        operator>>(std::istream& in, Sales_item& s)
        {
            double price;
            in >> s.bookNo >> s.units_sold >> price;
            // check that the inputs succeeded
            if (in)
                s.revenue = s.units_sold * price;
            else 
                s = Sales_item();  // input failed: reset object to default state
            return in;
        }

        std::ostream& 
        operator<<(std::ostream& out, const Sales_item& s)
        {
            out << s.isbn() << " " << s.units_sold << " "
                << s.revenue << " " << s.avg_price();
            return out;
        }

        double Sales_item::avg_price() const
        {
            if (units_sold) 
                return revenue/units_sold; 
            else 
                return 0;
        }
        #endif
        
# 模板类
      template<class genType>//声明模板类型
      class genClass{
            genType storage[50];//模板类型 数组
            };
      // 定义
      genClass<int>    intObject;   // int 类型数组
      genClass<double> doubleObject;// double 类型数组

      // 其二也可以将 数组大小推迟定义
      template<class genType, int size = 50>// 声明模板类型 书序大小默认为50
      class genClass{
            genType storage[size];//模板类型 数组
            };
      // 定义
      genClass<int>    intObject1;         // int 类型数组 默认   大小
      genClass<int, 100>    intObject2;    // int 类型数组 数组大小为 100 
      genClass<double, 123> doubleObject;  // double 类型数组  数组大小为 123

# 模板函数
      // 交换两个变量的值
      template<class genType>//声明模板类型
      void my_swap(genType& num1, genType& num2){   // 注意为 引用 需要对实参修改
            genType temp = num1;
            num1 = num2;
            num2 = temp;
          }
      

