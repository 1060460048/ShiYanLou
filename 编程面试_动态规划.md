# 搜索算法中的老祖宗，深度和广度优先搜索算法。
# 广度优先（BFS Breadth-First Search）搜索
          这个用形象的比喻，就像是地震波，从起点向外辐射，直到找到目标点。我们在实现的时候，一般采用队列来实现。
          广搜是一层一层往外遍历，寻找最短路径，其策略是采取队列的方法。
          这个算法的优点：
          1、简单。代码也就几十行；
          2、路径能找到最优解；
          不足：
          1、算法消耗的时间比较大，遍历的点会很多。
          
          广度优先搜索之所以能找到最优的路径，原因就是：
            每一次扩展的点，都是距离出发点最近、步骤最少的。
            如此这样递推，当扩展到目标点的时候，也是距离出发点最近的。
            这样的路径自然形成了最短的路线。
            


# 深度优先（DFS Depth-First Search）搜索
          用俗话说就是不见棺材不回头。算法会朝一个方向(目标位置)进发，直到遇到边界或者障碍物，才改变方向。
          一般在实现的时候，我们采用递归的方式来进行，也可以采用模拟压栈的方式来实现。
          这个算法的好处就是实现简单，可能就十几行代码。
          不过问题也很明显，就是：
          1、路径可能不是最优解；
          2、寻路时间比较长。

# A*算法  广度优先 + 启发式搜索  考虑距出发点距离 + 距目标点距离
          正是由于广度优先搜索一层层的扩展，虽然让他找到了最优的路线，
          但是，他却很傻的走完了绝大多数格子，才找到我们的目标点。
          也就是，他只关注了当前扩展点和出发点的关系，而忽略了当前点和目标点的距离。
          如果，如果，如果……我们每扩展一个点，就踮起脚尖，看看诗和远方，找找我们要寻找的那个目标，
          是不是就有可能指引我们快速的去往正确的方向，而不用傻乎乎的一层层的发展了呢？答案是肯定的。
          
          A*算法相对广度优先搜索算法，除了考虑中间某个点同出发点的距离以外，
          还考虑了这个点同目标点的距离。
          这就是A*算法比广度优先算法智能的地方。也就是所谓的启发式搜索。
 
> 如果用f(M)表示：从起点S到终点E（经过M点）的距离，那他就可以表示成为两段距离之和,M为中间策略点

          即：S→M的距离 + M→E的距离。如果我们用符号表示的话，就可以写成：f(M) = g(M) + h(M)。 
     
         我们扩展到M点的时候，S→M的距离就已经知道，所以g(M)是已知的。
         但是M到E的距离我们还不知道。如果我们能用某种公式，能大概预测一下这个距离，
         而这个预测的值又比较精确，我们是不是就能很精确的知道每一个即将扩展的点是否是最优的解路径上的点呢？ 
         
> 估算函数h(M)如何计算？

          常见的距离计算公式有这么几种：
          1、曼哈顿距离：这个名字听起来好高端，说白了，就是上面我们讲的横向格子数+纵向格子数(折线段距离)；
          2、欧式距离：这个名字听起来也很高端，说白了，就是两点间的直线距离sqrt((x1-x2)^2 + (y1-y2)^2)
          3、欧式距离平方： (x1-x2)^2 + (y1-y2)^2

          除了上述的距离计算公式以外，还有一些变种的距离计算公式，
          如：
          对角线距离等等。这个就在具体的问题中做具体的优化了。      

 > 不同估算函数对于结果的影响  
 
          1、当估算的距离h完全等于实际距离h'时，也就是每次扩展的那个点我们都准确的知道，
              如果选他以后，我们的路径距离是多少，这样我们就不用乱选了，每次都选最小的那个，
              一路下去，肯定就是最优的解，而且基本不用扩展其他的点。
              
          2、如果估算距离h小于实际距离h'时，我们到最后一定能找到一条最短路径(如果存在另外一条更短的评估路径，就会选择更小的那个)，
             但是有可能会经过很多无效的点。
             曼哈顿距离\欧式距离
             极端情况，当h==0的时候，最终的距离函数就变成：
             f(M)=g(M)+h(M)
             => f(M)=g(M)+0
             => f(M)=g(M)
             
          这不就是我们的广度优先搜索算法嘛？！ 他只考虑和起始点的距离关系，毫无启发而言。 
 
           3、如果估算距离h大于实际距离h'时，有可能就很快找到一条通往目的地的路径，但是却不一定是最优的解。
           这种情况就是h值大于等于实际距离的，明显他扩展的点很少，不过找到的路径却不是最短路径。
           欧式距离平方
           
           
           
           
         
         
          
          
          
          
