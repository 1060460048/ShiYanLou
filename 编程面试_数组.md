
# 数组面试题

        笔试和面试中，除了字符串，另一类出现频率极高的问题便是与数组相关的问题。
        解题思路：
        先一般考虑“万能的”暴力穷举（递归、回溯），如求n个数的全排列或八皇后（N皇后问题）。
        但因为穷举时间复杂度通常过高，所以需要考虑更好的方法。

        如   分治法（通过分而治之，然后归并）；

        以及 空间换时间（如活用哈希表）。

        此外，选择合适的 数据结构 可以显著提升效率，如寻找最小的k个数中，用 堆 代替 数组，也可借鉴快排思想，中枢分区方法。

        再有，如果题目允许排序，则可以考虑  排序。

        寻找和为定值的两个数中，先排序，然后用 前后两个指针 往中间扫描。

        而如果如果已经排好序了（如杨氏矩阵查找中），则想想有无必要二分，二分法。

        但是，如果题目不允许排序呢？这个时候，

        我们可以考虑 不改变数列顺序的 贪心算法（如 最小生成树Prim、Kruskal 及 最短路dijkstra）

        或 动态规划（如 01背包问题，每一步都在决策）。

        最后，注意细节处理，不要忽略边界条件，如字符串转换成整数。
        
## 第一题 寻找集合中的最小的K个数
        输入n个整数，输出其中最小的k个。
### 解法1 先排序再选择
        要求一个序列中最小的k个数，按照惯有的思维方式，
        则是先对这个序列从小到大排序，
        然后输出前面的最小的k个数。
        至于选取什么的排序方法，我想你可能会第一时间想到快速排序
        我们知道，快速排序平均所费时间为n*logn，
        然后再遍历序列中前k个元素输出即可。
        因此，总的时间复杂度：O（n * log n)+O(k)=O（n * log n）。
### 解法2 选择排序思想
        解法二

        咱们再进一步想想，题目没有要求最小的k个数有序，也没要求最后n-k个数有序。
        既然如此，就没有必要对所有元素进行排序。这时，咱们想到了用选择或交换排序，即：
        
        1、遍历n个数，把最先遍历到的k个数存入到大小为k的数组中，假设它们即是最小的k个数；
        
        2、对这k个数，利用选择或交换排序找到这k个元素中的最大值kmax（找最大值需要遍历这k个数，时间复杂度为O（k））；
        
        3、继续遍历剩余n-k个数。
           假设每一次遍历到的新的元素的值为x，把x与kmax比较：如果x < kmax ，用x替换kmax，
           并回到第二步重新找出k个元素的数组中最大元素kmax‘；如果x >= kmax，则继续遍历不更新数组，直到，k个数是此时最小的
           
        每次遍历，更新或不更新数组的所用的时间为O（k）或O（0）。故整趟下来，时间复杂度为n*O（k）=O（n*k）。  
### 解法3 利用最大堆 作为容器

        更好的办法是维护容量为k的最大堆，原理跟解法二的方法相似：
        
        1、用容量为k的最大堆存储最先遍历到的k个数，同样假设它们即是最小的k个数；
        
        2、堆中元素是有序的，令k1<k2<...<kmax（kmax设为最大堆中的最大元素）
        
        3、遍历剩余n-k个数。
          假设每一次遍历到的新的元素的值为x，把x与堆顶元素kmax比较：
          如果x < kmax，用x替换kmax，然后更新堆（用时logk）；
          否则不更新堆。
        这样下来，总的时间复杂度:O（k+（n-k）*logk）=O（n*logk）。
        此方法得益于堆中进行查找和更新的时间复杂度均为：O(logk)
        （若使用解法二：在数组中找出最大元素，时间复杂度：O（k））。  
        
### 解法4 利用快排思想 得到大小数的 分区中枢
        int Cut(int a[], int low, int high){
          int temp = a[low];// 区间第一个元素 可以随机选择 在替换到low的位置
          while(low < high){
            while((low < higt)&&(a[high] > temp)) --high;// 从右边向左寻找比 temp小的元素 a[higt]
            a[low] = a[high];// 把比temp小的元素 放在 原来temp的位置(左边小的区域)
            while((low < high)&&(a[low] < temp))  ++low;// 从左边寻找比 temp大的元素a[low] 放在右边 high的位置
            a[high] = a[low];
           }
          a[low] = temp; // 临时变量 放在 中枢位置
          return low;    // 返回中枢位置
        }

        // 在数组a中选择k个最小的元素  块选  非递归调用
        void QuickSelest(int a[], int low, int high, int k){
          int index =  Cut(a, 0, n-1);// 首先得到一个中枢
          while(index != k-1){// 非递归调用
          if(index > k - 1) index = Cut(a, low, index -1);// 左半部分小的元素个数大于k 在左半部分找 中枢
          else              index = Cut(a, index+1, high);// 左半部分小的元素个数小于k 右半部分还有，在右半部分找 中枢
          }
         // 打印
         for(int i = 0; i<k; ++i) cout<<a[i];
         cout << endl;
        }

        // 而快排为   是递归调用
        void QuickSort(int a[], int low, int high){
          int index;
          if(low < high){
            index = Cut(a, low, high);//选取中枢位置
            QuickSort(a, low, index-1);//对左边快排
            QuickSort(a, index+1, high);//对右边快排
          }
        }

        // 二分查找   非递归版本
        int BinarySearch(int a[], int low, int high, int key){
        int mid;//中间元素
        while(low < high){
        int mid = low + ((high - low)>>1);//中间元素的 下标 在循环体内 不停的被改变
        if( key < a[mid] )     high = mid - 1;// 查找的元素小于中值  高区间移至 mid-1
        elae if(key > a[mid] ) low  = mid + 1;// 查找元素大于中值， 将低区间移至 mid+1
        else return mid;
        }
        return -1;//未找打 返回-1
        }

        // 二分查找   递归版本
        int BinarySearch(int a[], int low, int higt, int key){
        int mid = low + ((high - low)>>1);//中间元素的 下标
        if(low < high){
          if(key < a[mid])      return BinarySearch(a, low, mid-1, key);
          else if(key > a[mid]) return BinarySearch(a, mid+1, high, key);
          else return mid;
        }
        return -1;
        }




