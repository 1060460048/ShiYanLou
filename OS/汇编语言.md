# 汇编语言简述
# 计算机系统结构
```c
cpu内部：　　　　　　　　　　　　　　　
1. PC Program Counter
   指令指针寄存器
   指向下一条指令的地址
   EIP(X86-32)或者
   RIP(X86-64)
2. 寄存器与寄存器堆
　 Registers
   在处理器CPU内部以名字来访问的快速存储单元
3. 条件状态码
　　 Condition Codes
    用于存储最近执行指令的结果状态信息
    用于条件指令的判断执行
内存单元Memory：
　　以字节编码的连续存储空间
    存储程序代码、数据、运行栈stack 以及操作系统数据
```
# 汇编语言数据格式
```c
c 语言          数据类型　　　汇编代码后缀　　大小(字节为单位)
char               字节         b  byte       1
short　　　　　　　 字           w  word       2
int　　　　　　　　 双字         l              4
long int　　　　　 双字         l              4
long long int　　　无           无             4
char*　　　　　　  双字　　　　　l              4
float　　　　　　　单精度       s               4
double　　　　　　 双精度       l               8
long double 　　　扩展精度      t              10/12
```
# 第一条汇编指令实例
```c
c 语言代码：
　int t = x+y // 两个整数(32位)
汇编代码：
　addl 8(%ebp) %eax//l表示双字　８是位偏移量
  操作数：
  x: 寄存器　Register  eax
  y: 内存    Memory   M[ebp+8]   ebp是栈基址寄存器
  t: 寄存器  Register eax
  结果t保存在寄存器eax中
类似于表达：
　x　+=　y
或者：
  int eax;
  int* ebp;
  eax += ebp[2];//这里按字节
```
# 数据传送指令
```c
movel 源地 目的地
将一个双字从源地移动到目的地
允许的操作数类型有:
   立即数Imm:常整数
      如: $0x400, $-533
      可以用1,2或4个字节来表示
   寄存器 Reg:
      8个通用寄存器之一
      %eax
      %ebx
      %ecx
      %edx
      %esi
      %edi
      %esp
      %ebp
   存储器Mem:四个连续的字节
                     汇编　　　　　　　类似C语言
立即数--->寄存器　 movl $0x41, %eax     temp = 0x41;
立即数--->内存     movl $-43, (%eax)    *p   = -43;
寄存器--->寄存器   movl %eax, %edx      temp2 = temp;
寄存器--->内存     movl %eax, (%edx)    *p    = temp;
内存　--->寄存器   movl (%eax), %edx    temp  = *p;
不允许内存到内存  
```
# 简单得寻址模式
```c
1. 间接寻址 (R)     Mem[Reg[R]]
寄存器Ｒ指定得内存地址
movl (%ecx), %eax
2. 基址＋便宜量寻址　D(R)  Mem[Reg[R] + D]
寄存器Ｒ指定内存的起始地址
常数Ｄ给出偏移地址
movl 8(%ebp), %ecx
```
# 寻址模式使用示例
```asm
交换两个数
C语言
void swap(int* xp, int* yp){
int t0 = *xp;
int t1 = *yp;
*xp = t1;
*yp = t0;
}

汇编语言分析
寄存器 变量：
%ecx   yp
%edx   xp
%eax   t1
%ebx   t0
对应汇编：
movl 12(%ebp),%ecx  # ecx = yp  是地址　　放到ecx寄存器中
movl 8(%ebp), %edx  # edx = xp　是地址　　放到edx寄存器中
movl (%ecx), %eax   # eax = *yp t1 值  　取寄存器中地址指向的内存地址中的内容放入 寄存器eax中
movl (%edx), %ebx   # ebx = *xp t0 值　　取寄存器中地址指向的内存地址中的内容放入 寄存器ebx中
movl %eax, (%edx)   # *xp = eax          交换内容放入原来内存指向得地址中
movl %ebx, (%ecx)   # *yp = ebx

ebp 是函数栈　基地址
ebp+8　的位置　存储　指针xp　指向内存的一个地址
ebp+12 的位置　存储　指针yp　指向内存的一个地址
```


