# 汇编语言简述
# 计算机系统结构
```c
cpu内部：　　　　　　　　　　　　　　　
1. PC Program Counter
   指令指针寄存器
   指向下一条指令的地址
   EIP(X86-32)或者
   RIP(X86-64)
2. 寄存器与寄存器堆
　 Registers
   在处理器CPU内部以名字来访问的快速存储单元
3. 条件状态码
　　 Condition Codes
    用于存储最近执行指令的结果状态信息
    用于条件指令的判断执行
内存单元Memory：
　　以字节编码的连续存储空间
    存储程序代码、数据、运行栈stack 以及操作系统数据
```
# 汇编语言数据格式
```c
c 语言          数据类型　　　汇编代码后缀　　大小(字节为单位)
char               字节         b  byte       1
short　　　　　　　 字           w  word       2
int　　　　　　　　 双字         l              4
long int　　　　　 双字         l              4
long long int　　　无           无             4
char*　　　　　　  双字　　　　　l              4
float　　　　　　　单精度       s               4
double　　　　　　 双精度       l               8
long double 　　　扩展精度      t              10/12
```
# 第一条汇编指令实例
```c
c 语言代码：
　int t = x+y // 两个整数(32位)
汇编代码：
　addl 8(%ebp) %eax//l表示双字　８是位偏移量
  操作数：
  x: 寄存器　Register  eax
  y: 内存    Memory   M[ebp+8]   ebp是栈基址寄存器
  t: 寄存器  Register eax
  结果t保存在寄存器eax中
类似于表达：
　x　+=　y
或者：
  int eax;
  int* ebp;
  eax += ebp[2];//这里按字节
```
# 数据传送指令
```c
movel 源地 目的地
将一个双字从源地移动到目的地
允许的操作数类型有:
   立即数Imm:常整数
      如: $0x400, $-533
      可以用1,2或4个字节来表示
   寄存器 Reg:
      8个通用寄存器之一
      %eax
      %ebx
      %ecx
      %edx
      %esi
      %edi
      %esp
      %ebp
   存储器Mem:四个连续的字节
                     汇编　　　　　　　类似C语言
立即数--->寄存器　 movl $0x41, %eax     temp = 0x41;
立即数--->内存     movl $-43, (%eax)    *p   = -43;
寄存器--->寄存器   movl %eax, %edx      temp2 = temp;
寄存器--->内存     movl %eax, (%edx)    *p    = temp;
内存　--->寄存器   movl (%eax), %edx    temp  = *p;
不允许内存到内存  
```
# 简单得寻址模式
```c
1. 间接寻址 (R)     Mem[Reg[R]]
寄存器Ｒ指定得内存地址
movl (%ecx), %eax
2. 基址＋便宜量寻址　D(R)  Mem[Reg[R] + D]
寄存器Ｒ指定内存的起始地址
常数Ｄ给出偏移地址
movl 8(%ebp), %ecx
```
# 寻址模式使用示例
```asm
交换两个数
C语言
void swap(int* xp, int* yp){
int t0 = *xp;
int t1 = *yp;
*xp = t1;
*yp = t0;
}

汇编语言分析
寄存器 变量：
%ecx   yp
%edx   xp
%eax   t1
%ebx   t0
对应汇编：
movl 12(%ebp),%ecx  # ecx = yp  是地址　　放到ecx寄存器中
movl 8(%ebp), %edx  # edx = xp　是地址　　放到edx寄存器中
movl (%ecx), %eax   # eax = *yp t1 值  　取寄存器中地址指向的内存地址中的内容放入 寄存器eax中
movl (%edx), %ebx   # ebx = *xp t0 值　　取寄存器中地址指向的内存地址中的内容放入 寄存器ebx中
movl %eax, (%edx)   # *xp = eax          交换内容放入原来内存指向得地址中
movl %ebx, (%ecx)   # *yp = ebx

ebp 是函数栈　基地址
ebp+8　的位置　存储　指针xp　指向内存的一个地址
ebp+12 的位置　存储　指针yp　指向内存的一个地址
```

# 变址寻址
```c
常见形式：
   D(Rb,Ri,S) Mem[Reg[Rb] + S*Reg[Ri] + D]
 D:  常量（地址偏移量）
 Rb: 基址寄存器：８个通用寄存器之一
 Ri: 索引寄存器： %esp不作为索引寄存器
 　　　　　　　　一般%ebp也不做这个用途
 S: 比例因子, 1,2,4,8
 其他变形：
   D(Rb,Ri) Mem[Reg[Rb] + Reg[Ri] + D]
   (Rb,Ri) Mem[ Reg[Rb] + Reg[Ri] ]
   (Rb,Ri) Mem[Reg[Rb] + S*Reg[Ri]]
 ```
 # 地址计算指令　leal  lea  +l
 ```asm
 leal src, dest
   src 是地址计算表达式子
   计算出来得地址赋给　dest
 使用实例：
   地址计算，无需访问内存　auto *p = &x[i];
   进行x+k*y这一类型得整数计算，k = 1,2,4,8
```
# 整数计算指令：
```asm
addl src,dest   #  dest = dest + src #加法
subl src,dest   #  dest = dest - src #减法
imull src,dest  #  dest = dest * src #乘法
sall src,dest  #  dest = dest << src #左移位 等价于shll
sarl src,dest  #  dest = dest >> src #算术右移位　补　被移动数的最高位 
shrl src,dest  #  dest = dest >> src #逻辑右移位　左边单纯补　０
xorl src,dest  #  dest = dest ^ src  #按位异或
andl src,dest  #  dest = dest & src  #按位与
orl  src,dest  #  dest = dest | src  #按位或

incl dest  #  dest = dest + 1  #++ 自增１
decl dest  #  dest = dest - 1  #-- 自减１
negl dest  #  dest = - dest #　取非
notl dest  #  dest = ~ dest #  取反
```

# 将leal指令用于计算
```asm
c语言：
   int temp(int x, int y){
      int t1 = x+y;
      int t2 = z+t1;
      int t3 = x+4;
      int t4 = y*48;
      int t5 = t3+t4;
      int ret = t2*t5
      return ret;
   }
汇编代码：
   movl 8(%ebp), %eax   # eax = x
   movl 12(%ebp), %edx  # edx = y
   leal (%eax, %edx), %ecx # t1  = ecx = x+y 
   addl 16(%ebp), %ecx     # t2 = ecx = z+t1
   leal (%edx,%edx,2), %edx # edx = 3*y
   sall $4, %edx            # t4 = edx = 2^4 * 3 * y =16*3*y = 48*y
   leal 4(%eax,%edx), %eax  # t5 = eax =4+x+t4
   imul %ecx, %eax          # ret = eax = t2*t5
```

# 逻辑运算示例
```asm
C语言：
   int logical_(int x, int y){
      int t1 = x^y;
      int t2 = t1>>17;
      int mask = (1<<13) - 7;
      int ret = t2 & mask;
      return ret;
   }
汇编语言：
movl 8(%ebp), %eax  # eax = x
xorl 12(%ebp), %eax # t1 = eax = x^y  
sarl $17, %eax      # t2 = eax = t1 >> 12
andl $8185, %eax    # ret = eax = t2 & 8185  2^13-7 = 8185 这里编译器会算出来
```
