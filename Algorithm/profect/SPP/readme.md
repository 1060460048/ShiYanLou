# 最短路径问题 shortest path problem

## 问题解释： 

从图中的某个顶点出发到达另外一个顶点的所经过的边的权重和最小的一条路径，称为最短路径

## 解决问题的算法：

1. 迪杰斯特拉算法（Dijkstra算法）

2. 弗洛伊德算法（Floyd算法）

3. SPFA算法



## SPFA算法介绍
[最短路径问题---SPFA算法详解](https://blog.csdn.net/qq_35644234/article/details/61614581)

      SPFA算法是求解单源最短路径问题的一种算法，由理查德·贝尔曼（Richard Bellman） 和 莱斯特·福特 创立的。
      有时候这种算法也被称为 Moore-Bellman-Ford 算法，因为 Edward F. Moore 也为这个算法的发展做出了贡献。
      它的原理是对图进行V-1次松弛操作，得到所有可能的最短路径。
      其优于迪科斯彻算法的方面是边的权值可以为负数、实现简单，
      缺点是时间复杂度过高，高达 O(VE)。但算法可以进行若干种优化，提高了效率。

      算法的思路： 
      我们用数组dis记录每个结点的最短路径估计值，用邻接表或邻接矩阵来存储图G。
      我们采取的方法是动态逼近法：设立一个先进先出的队列用来保存待优化的结点，
      优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，
      如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。
      这样不断从队列中取出结点来进行松弛操作，直至队列空为止

      我们要知道带有负环的图是没有最短路径的，所以我们在执行算法的时候，要判断图是否带有负环，方法有两种：

      开始算法前，调用拓扑排序进行判断（一般不采用，浪费时间）
      如果某个点进入队列的次数超过N次则存在负环（N为图的顶点数）
