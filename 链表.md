# 单向链表  link list
     t数组的局限：编译期就需要知道大小； 内存连续，插入困难
     
        // 链表节点类 包含一个信息 和指向下一个 节点的指针
        clas IntLLNode{
        public:
            IntLLNode(){// 默认构造函数   没有info信息
                nextPtr_ = 0;// 空指针
            }
            IntLLNode(int data, IntLLNode* in = 0){// 第二个构造函数
                info_    = data;
                nextPtr_ = in;
            }
        public:
            int info_;          // 包含一个信息          对用户很重要
            IntLLNode* nextPtr_;// 指向下一个 节点的指针  用于将节点连接起来组成链表
        }

        // 定义一个 节点指针
        IntLLNode* pt = new IntLLNode(10);//新建一个节点 其地址 赋给一个指向 IntLLNode 的指针 pt
        //
        //   [pt]  ----> |  10 | 也就是 pt->info_   也就是 (*pt).info_
        //               |  \  | 也就是 pt->nextPtr_ 也就是 (*pt).nextPtr_ 

        // 再定义一个节点
        pt->nextPtr  = new IntLLNode(30);//新建一个节点 其地址 赋给一个指向 IntLLNode 的指针 pt->nextPtr_
        //
        //   [pt]  ----> |  10 |  
        //               |     |  -----> | 30 | 也就是 pt->nextPtr_->info_
        //                               | \  | 也就是 pt->nextPtr_->nextPtr_

        // 再定义一个节点
        pt->nextPtr_->nextPtr_  = new IntLLNode(50);
        //新建一个节点 其地址 赋给一个指向 IntLLNode 的指针 pt->nextPtr_->nextPtr_
        //
        //   [pt]  ----> |  10 |  
        //               |     |  -----> | 30 |  
        //                               |    | ------> | 50 | 也就是  pt->nextPtr_->nextPtr_->info_
        //                                              |  \ | 也就是  pt->nextPtr_->nextPtr_->nextPtr_


## 使用 头结点和尾节点来存储链表结构
     //************************  intSLList.h  **************************
     // 单链表 实现类 

     #ifndef INT_LINKED_LIST
     #define INT_LINKED_LIST

     // 单个节点
     // 定义一个 节点指针
     // IntLLNode* pt = new IntLLNode(10);//新建一个节点 其地址 赋给一个指向 IntLLNode 的指针 pt
     //
     //   [pt]  ----> |  10 | 也就是 pt->info_   也就是 (*pt).info_
     //               |  \  | 也就是 pt->nextPtr_ 也就是 (*pt).nextPtr_  
     class IntSLLNode {
     public:
         IntSLLNode() {// 默认构造函数   没有info信息
             next = 0;// 空指针
         }
         IntSLLNode(int data, IntSLLNode *ptr = 0) {// 第二个构造函数
             info = data; 
       next = ptr;
         }
     public:    
         int info;         // 包含一个信息          对用户很重要
         IntSLLNode *next; // 指向下一个 节点的指针  用于将节点连接起来组成链表
     };

     // 链表 类  保存了一个 头节点 和 一个尾节点 
     class IntSLList {
     public:
         IntSLList() {// 默认构造函数  这里定义和实现 
             head = tail = 0;// 节点 和 一个尾节点 指针赋值为 空 
         }
         ~IntSLList();// 默认析构函数  只有定义 实现在 cpp文件中 
         int isEmpty() {//为空链表是否 
             return head == 0;
         }
         void addToHead(int);   // 从头部添加 节点 
         void addToTail(int);   // 从尾部添加 节点 
         int  deleteFromHead(); // 从头部删除 节点 并返回该节点的信息 
         int  deleteFromTail(); // 从尾部删除 节点 并返回该节点的信息 
         void deleteNode(int);//删除 
         bool isInList(int) const;
         void printAll() const;//打印所有的节点的信息   
     private:
         IntSLLNode *head, *tail;// 保存了一个 头节点 和 一个尾节点
     };
     #endif
     
[实现类cpp intSLList.cpp](datastructure_code/cpp_version/intSLList.cpp)

### 头部插入节点   head 和 tail  仅仅是保存了 一个(节点)存储的地址
       head ---> | 5 |  
                 |   | ---> | 7 |
                            |   | --->  |  4 | <-------- tail
                                        |    |
       新建一个节点                                 
       | 9 |  head ---> | 5 |  
       |   |            |   | ---> | 7 |
                                   |   | --->  |  4 | <-------- tail
                                               |    |   
       新节点指向 head 指向的地址   new IntSLLNode9, head);
       | 9 |  head ---> | 5 |  
       |   | ------->   |   | ---> | 7 |
                                   |   | --->  |  4 | <-------- tail

        原头结点指向新节点  head = new IntSLLNode(9,head);
        head --->  |   | 
                   | 9 |  
                   |   | -------> | 5 |  
                                  |   | ---> | 7 |
                                             |   | --->  |  4 | <-------- tail
                                                         |    |       
                                                         
### 尾部插入一个节点
     head ---> | 5 |  
               |   | ---> | 7 |
                          |   | --->  |  4 | <-------- tail
                                      |    |
     尾部新建一个节点     new IntSLLNode(9);                             
      head ---> | 5 |  
                |   | ---> | 7 |
                                 |   | --->  |  4 | <-------- tail
                                             |    |                 | 9 |   
                                                                    | \ |                                 tail指向的节点 指向这个新节点   tail->next = new IntSLLNode(9)
      head ---> | 5 |  
                |   | ---> | 7 |
                                 |   | --->  |  4 | <-------- tail
                                             |    | -------->   | 9 |   
                                                                | \ | 

     尾节点tail 指向新的 尾节点   tail = tail->next;
      head ---> | 5 |  
                |   | ---> | 7 |
                                 |   | --->  |  4 | 
                                             |    | -------->  | 9 |   <-------- tail
                                                               | \ |                                 
# 双向向链表  link list  节点同时包含 指向前驱节点的指针 也包含 指向后继节点的指针
[双向向链表](datastructure_code/cpp_version/genDLList.h)




