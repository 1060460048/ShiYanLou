# 单向链表  link list
     t数组的局限：编译期就需要知道大小； 内存连续，插入困难
     
        // 链表节点类 包含一个信息 和指向下一个 节点的指针
        clas IntLLNode{
        public:
            IntLLNode(){// 默认构造函数   没有info信息
                nextPtr_ = 0;// 空指针
            }
            IntLLNode(int data, IntLLNode* in = 0){// 第二个构造函数
                info_    = data;
                nextPtr_ = in;
            }
        public:
            int info_;          // 包含一个信息          对用户很重要
            IntLLNode* nextPtr_;// 指向下一个 节点的指针  用于将节点连接起来组成链表
        }

        // 定义一个 节点指针
        IntLLNode* pt = new IntLLNode(10);//新建一个节点 其地址 赋给一个指向 IntLLNode 的指针 pt
        //
        //   [pt]  ----> |  10 | 也就是 pt->info_   也就是 (*pt).info_
        //               |  \  | 也就是 pt->nextPtr_ 也就是 (*pt).nextPtr_ 

        // 再定义一个节点
        pt->nextPtr  = new IntLLNode(30);//新建一个节点 其地址 赋给一个指向 IntLLNode 的指针 pt->nextPtr_
        //
        //   [pt]  ----> |  10 |  
        //               |     |  -----> | 30 | 也就是 pt->nextPtr_->info_
        //                               | \  | 也就是 pt->nextPtr_->nextPtr_

        // 再定义一个节点
        pt->nextPtr_->nextPtr_  = new IntLLNode(50);
        //新建一个节点 其地址 赋给一个指向 IntLLNode 的指针 pt->nextPtr_->nextPtr_
        //
        //   [pt]  ----> |  10 |  
        //               |     |  -----> | 30 |  
        //                               |    | ------> | 50 | 也就是  pt->nextPtr_->nextPtr_->info_
        //                                              |  \ | 也就是  pt->nextPtr_->nextPtr_->nextPtr_




