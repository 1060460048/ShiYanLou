# c 示例代码

## 1.基础数据类型 打印相关 宏定义 变量

```c

#include <stdio.h>

//预定义 定义符号常量
#define NAME "fyf"
#define YEAR 1987
#define URL "https://www.qq.com"
/*	
 *	标识符identifier: 用于给变量，常量，函数，语句块等命名
 *
 *	常量：constant
 *	整数常量：250 , 12345
 *	实数常量：1.23 ， 35.99 ， 0.1 （float和double）
 *	字符常量：
 *		-普通字符：‘f’ , 'y' , 'F'
 *		-转义字符：'/n', '/t', '/b'
 *	字符串常量："FYFfyf"
 *
 *	定义符号常量：
 *		格式：#define 标识符 常量（宏定义）
 *		为与变量区分，符号常量通常用大写字母表示,非硬性规定
 *		#define YEAR 1987
 *		#define NAME "fyf"
 */

/*
 * 数据类型：
 * 	1.基本类型：
 * 		a.整数类型 int
 * 		b.浮点数类新 float double
 * 		c.字符类型 char
 * 		d.布尔类型 _Bool
 * 		e.枚举类型 enum
 * 	2.指针类型
 * 	3.构造类型：
 * 		a.数组类型
 * 		b.结构类型
 * 		c.联合类型
 * 	4.空类型
 *
 * 限定符：
 * 整数类型：short int , int , long int , long long int
 * short int <= int <=long int <=long long int
 * 
 * 浮点数类型：float , double , long double
 * 布尔类型：_Bool
 * 枚举类型：enum
 */


int main(void)
{
    printf("Name: %s,Year: %d年\n", NAME, YEAR);
// \n 输出换行 \ 同一行代码分行
/* \n 输出换行 \ 同一行代码分行 */
// printf print format
    printf("Hello World!\n\
		    ++++++\n\
		    +\n\
		    +\n\
		    ++++++\n\
   	            +\n\
   	            +\n\
   	            +\n\
   	            +\n");
//  定义变量 various variable
//  数据类型 变量名
    int a;
    char b;
    float c;
    double d;
//  变量 = 常量  （变量可改变，常量不可改变）
    a = 250;
    b = 'F';
    c = 3.14;
    d = 3.141592653;
// %d %c %f 转换说明
    printf("This is integer: %d\n" ,a);
    printf("This is charactor: %c\n" ,b);
    printf("This is float: %.2f\n" ,c);
    printf("This is double: %10.10f\n" ,d);
// sizeof()运算符：返回变量的大小
// 用法：sizeof(object对象)  sizeof(type_name类型)  sizeof object对象
    printf("The size of short int:%d\n", sizeof(short int));
    printf("The size of int:%d\n", sizeof(int));
    printf("The size of long int:%d\n", sizeof(long int));
    printf("The size of long long int:%d\n", sizeof(long long int));
    printf("The size of float:%d\n", sizeof(float));
    printf("The size of double:%d\n", sizeof(double));
    printf("The size of long double:%d\n", sizeof(long double));
    printf("The size of char:%d\n", sizeof(char));
    printf("The size of _Bool:%d\n", sizeof(_Bool));
    printf("The size of a:%d\n", sizeof(a));
    printf("The size of b:%d\n", sizeof(b));

    return 0;

}

````

## 2. 函数定义 声明 调用
```c
#include <stdio.h>

void jolly(void);
void deny(void);
void nation1(void);
void nation2(void);

int main(void)
{
    int dogs;

    printf("How many dogs do you have?\n");
    scanf("%d", &dogs);
    printf("So you have %d dog(s)!\n", dogs);
    printf("Dogs\n/nDogs\n");

    jolly();
    deny();

    nation1();
    printf(", ");
    nation2();
    printf("\n");
    nation1();
    printf(",\n");
    nation2();
    printf("\n");
    
    return 0;
}

void jolly(void)
{
    printf("Welcome! Jolly.\n");
}

void deny(void)
{
    printf("Welcome! deny.\n");
}

void nation1(void)
{
    printf("A, B");
}

void nation2(void)
{
    printf("C, D");
}



```


## 3. 数值 编码 十进制 
```c
#include <stdio.h>
/*
 *A.十进制(十进制计数法): 由是十个基数0,1,2,3,4,5,6,7,8,9表示,满十进一
 *个人理解: 数位1[十个基数(符号)最大只能表示九,然后9+1,数位1已经没有符号表示十了,假设数位1上有十根辣条,数位1已经没有符号表示十根
 *辣条了,然后把十根辣条捆成一捆,丢到数位2(1进位到数位2,进位2的1(一捆辣条)表示十根辣条,1*10(读成1个10更好理解),10为数位2的位权),
 *所以数位2变成1,数位1变成0(因为十根辣条已经全部放到数位2了,所以数位1就一根辣条也没有了),所以10(读作一零更好理解)表示十]
 *
 * 二进制跟上面的十进制概念是一样的,只是基数变成0,1。满二进一
 * 二进制转换成其他进制:
 * (1111)2=1*2^3+1*2^2+1*2^1+1*2^0=8+4+2+1= (15)10十进制 (e)16十六进制 (17)8八进制 
 * (平时都是用十进制,不理解十进制的定义,思维固化,虽知道转换方法,但不懂其中的原理,时间一久就忘了,脑子转不过弯,知其然不知其所以然... --`)
 * 1111 1111 = (255)10 [0000 0000,1111 1111]=[0,255]区间有256个符号表示0~255
 * 1 0000 0000 = (256)10 [0000 0000,1 0000 0000]=[0,256]区间有257个符号表示0~256
 * 位权:因为平时都习惯用十进制,所以位权就用十进制表示吧,换成其实进制脑子不够用(要不人类发明计算机干嘛呢～),习惯真可怕。。。
 * 位权通俗来说就是每一数位的1表示多少根辣条(平时用开十进制,梗系用十进制表示位权啦,啊!!!十进制已经灌进了我脑中无法磨灭了)
 *
 * B.机器数的真值(机器数的形式值:看了定义感觉跟无符号数一样)
 * 机器数:一个数在计算机中的二进制表示,机器数是带符号的
 * 例如: 1000 0001的真值=-000 0001=(-1)10  1000 0001的形式值=(129)10
 *
 *
 * C.二进制代码-->数据类型的本质就是分配存储空间长度-->转换说明才决定输出的数据字面量(常量)
 *整数常量integer constants(C语言中字符常量character constants也被当作整数常量)
 *在声明(declaration)变量时,整数常量(由上可知当然也包含字符常量,字符常量本质上在计算机存储二进制代码中算是整数常量的子集,)
 *赋值给变量,如果该整数字面量(整数常量)大于或小于该数据类型所代表的整数字面量的区间,编译器编译时会报错,
 *但非声明变量时不会报错,会出现整数溢出,得不到正确结果.
 *
 *以8bits有符号数为例,除去一个符号位,数值位共7位,模1000 0000,模mod为2^7。
 *以十进制数为例,个位的模为10^1,十位的模位10^2,以此类推. 10^n/10^m=10^(n-m) 10^1/10^1=10^(1-1)=10^0=1
 *以十进制为例,数学公式(同余式-通俗说就是余数相同):-3=7(mod10) mod10表示模是10, 7是(-3)对10的补数
 */
/*
  位置计数系统小数的本质:
      (0.1)10  = 1/10       一根辣条变10份,十分之一根辣条
               = 1/10^1
               = 1*10^0/10^1
               = 1*10^(0-1)
               = 1*10^-1
               = 10^-1
    10的0次方为什么等于1:
       10^0 = 10/10         十根辣条除于十,变一根辣条
            = 10^1/10^1
            = 10^(1-1)
            = 10^0
            = 1
    10的2次方除于10的1次方:
       10^2/10^1 = 100/10 = 100 * 1/10     100根辣条,分成十份,只剩一份了
                 = 10
                 = 10^1
                 = 10^(2-1)
    小数点向左移一位和向右移一位的本质:
        (11.11)2  ---小数点左移一位---> (1.111)2  
        本质:(这里用十进制表述),从最高位起,两根辣条变一根,一根辣条变1/2根,1/2根变1/4根
        (11.11)2  ---小数点右移一位---> (111.1)2
        本质:跟上面道理一样,只不过刚好相反,2根辣条变4跟,以此类推......  
*/
// 十六进制与二进制的关系:
//         x[1]                    x[0]               一位x取值范围[0,15] --> [0,f]
//  d[7] d[6] d[5] d[4]    d[3] d[2] d[1] d[0]        四位d取值范围[0,15] --> [0000,1111]
//  (  5   f  )16 
//  (0101 1111)2
// 四位二进制数 对应 一位十六进制数
//*理解的关键,满十六进位(把二进制的四位理解为十六进制中的一位就行了),这句才是理解重点,
//本质就是满十六进一,也是位置计数系统的本质啊
// 十六进制的一位用 0~f十六个符号表示,相当于用四位二进制 0000~1111十六种编码方式分别表示十六进制中的 0~f
// 八进制与二进制的关系原理也是一样的
//
int main(void)
{
    //*tips:C语言将字符常量视为int数据类型而非char数据类型
    //char字符类型本质上是整数类型,
    //ascii码和unicode码都是用整数来表示字符和符号
    //ascii码一个byte字节就能储存完(字母大小写和标点符号)
    //ascii码中'A' 对应整数65
    char c1 = 'A';
    char c2 = 65;
    char c3 = 255;
    //int -128二进制:1000 0000 0000 0000 0000 0000 1000 0000 -128很特殊,它没有原码反码,只有补码,具体查看补码的定义
    //          补码:1000 0000 0000 0000 0000 0000 1000 0000
    //int   -1二进制:1000 0000 0000 0000 0000 0000 0000 0001
    //          补码:1111 1111 1111 1111 1111 1111 1111 1111
    //-128-1 运算: 1(1111 1111 1111 1111 1111 1111 0111 1111) 结果为负数,补码与原码不一样,所以要得到正确结果还要转成原码
    //       原码:   1000 0000 0000 0000 0000 0000 1000 0001  原码转换成十进制结果,得到-129
    //                                             1*2^7+1*2^0=129   2^(n-1)为二进制中第n位的位权 
    //char c4 = -129; 编译时报错,溢出
    //char c4 = 256;  编译时报错,溢出
    //char c4 = -256; 编译时报错,溢出

    short int hi1 = -32768;
    
    int i1 = 'A';
    int i2 = 65;

    //非打印字符 P134:
    //1.直接ascii码赋值(转换成int数据类型赋值)
    char beep = 7;
    //2.转义序列(escape sequence)
    char newline = '\n';
    short int int_newline = '\t';
    /* 个人理解:字符常量虽被C语言视为int类型(整数常量),但声明时(declaration)给变量(除布尔型)赋值没有溢出overflow错误
      (因为ascii码不超过8bit,视为int类型前面的bit全部填充为0,整数字面量在[-128,255]区间),
       int数据类型声明变量赋值时,如果超过int类型的数值范围编译器会提示overflow出错
       运算后溢出编译器不会提示错误,但得到的结果并不正确(整数溢出) */
    short int a = 100,sum; 
    
    //布尔类型:true,false 1,0 占1bit存储空间
    _Bool b;
    
    //运算结果超出了声明时分配给变量sum的存储长度,整数溢出
    sum = a + 1000000;

    printf("sum:%hd\n", sum);

    printf("char size:%dbyte\n", sizeof(c1));
    printf("int size:%dbyte\n", sizeof(i1));
    printf("character c1='A' 转换说明i-->%d,character c2=65 转换说明c-->%c\n", c1, c2);
    printf("integer i1='A' 转换说明i-->%d,integer i2=65 转换说明c-->%c\n", i1, i2);
    
    //P135 有需要就到转义序列表查看即可
    /*常用 转义序列: \t \b \n \r \' \" \\ 非打印字符*/
    printf("转义序列例如: '\\\\' '\\\"' '\\t',转义序列(非打印字符)\\n效果:%c", newline);     
    printf("字符变量character variable size:%d\n", sizeof(newline));//字符变量占一个字节
    printf("字符常量character constants size:%d\n", sizeof('\n')); //得出tips的结论,字符常量占4个字节
    printf("-128 C compiler当作int数据类型,size:%d\n", sizeof(-129));
    printf("%c\n", c3);
    printf("%hx,%hx,%x\n", -1,-128,-128-1);
    printf("%hx\n", hi1);
    printf("布尔数据类型_Bool variable b size:%d\n", sizeof(b));
    return 0;
}

```


## 4. 打印格式 限制 数值意义
```c
#include <stdio.h>
//c库中的文件<limits.h>定义了一组常量,用来限定编译器complier运行的这台机器的整型数据类型的取值范围
#include <limits.h> 
//预备知识:
//+1元:我有1元钱; -1元:我欠某人1块钱,也可以说我有-1元钱...
//1-2= 怎么得到结果-1
//1-2 = -2+1 = -1*2 + -1*-1 = -1*[2+(-1)] = -1*(2-1) = -1*1 = -1 (一个-1)
//-----------------------------------------------------------------------------------
//上面第三步还有一个知识点: 1 = -1*-1 (负负得正)
//那负数乘负数为什么得正呢。。。
//2-2 = 2+(-2) = 0
//[2+(-2)] * (-3) = 0 * (-3)
//2*(-3) + (-2)*(-3) = 0 乘法分配律
//(-6) + (-2)*(-3) = 0
//两边同时+6    6+(-6) + (-2)*(-3) = 6+0
// (-2)*(-3) = 0 + 6 = 6 由此推到出负负得正的结论  
//日常生活中的解释: 我欠甲人3元,欠乙人3元, 我拥有(-3) + (-3) = -6元, 再-(-6),现实生活中(-)要还6元,
//但我现在身上有0元,所以我要先赚6元,所以0+6
//所以要-(-6)要减去负债6元 = +6赚6元 
//-----------------------------------------------------------------------------------
//上面第四步还有一个知识点，公因式(commom factor)
// a*c + c*b = c*(a+b) 提取公因式
//-----------------------------------------------------------------------------------
//理解的关键点一:二进制数的原码补码 与 机器数的原码补码 有所不同
//理解的关键点二:平时我们已经习惯十进制的思维,所以用十进制举例来解释二进制的机器码原理,更有助于理解
//              mod模为10,0~9十个基数,+表示正数,-表示负数(机器码中0表示正数,1表示负数原理是一样的);
//              取值范围:-10~+9,根据机器码补码规则,用-0表示-10;
//              -9是+1对于模10的补数,根据机器码的规则,用-9(相当于机器码中的补码)代表-1(所以符号位不变,数值位求补码)
//              《计算机科学导论第三版》P32 图3-8 有助于具象化理解 关键点二
//
//二进制数原码和补码是相互的,二进制数原码0000 0001 补码1111 1111;二进制数原码1111 1111 补码0000 0001
//二进制数0000 0001(机器数+1) 补码1111 1111(二进制数+1的补码,机器数-1的补码) 
//1000 0001(机器数-1的原码,机器数-1补码转原码,符号位不变)
//-----------------------------------------------------------------------------------
//二进制数运算 0000 0010
//参考:《计算机科学导论第三版》 P34 图3-9  P55 二进制补码加减法  P57 第一段话
//理解机器码补码加减运算关键点一：
//    引入数学概念:模运算
//                 模是一个计量器的计数范围
//                 计算机的数据位数(字长)是有限的,计算机也可以看成是一个计量器,所以必然是模运算,
//                 比如说钟表,它所能表示的整点情况只有十二种,所以它的模是12
//    a.在模运算中,假设模为M,一个整数和一个负数互为补数时,两个数的绝对值之和为模
//    b.在模运算中,减去一个数等于加上这个数的补数
//     模运算:   M=10  8+10=8
//                     9+(-6)=3   9+4=3 
//                                9+(-6)+10=3
//    补数是一种处理有符号数的方法,用于变换数字的符号.在计算机科学应用中被称为"补码"
//    补码的定义: [x补] = M + x  
//            1) x >= 0, 模M作为超出部分要被舍去,[x补]=x,因此正数的补码就是其本身
//            2) x < 0, [x补]就是x以M为模的补数
//    一个数的补数等于模加这个补数,再取模求余.
//
//-----------------------------------------------------------------------------------
//理解机器码补码加减运算关键点二：
//    参与运算的每个数和结果要在分配的二进制位的定义范围内,超出了就发生溢出错误了
//理解重点:(以4bit字长为例)本质就是[0000,1111]之间的数进行加法运算(同余定理解决了减法变加法的问题),
//        且结果还在[0000,1111]中, 结果代表的实际数字在设计计算机时规定了,根据规定方法换算得到原码即可,
//        但机器码原码所代表的实际数字(数学意义上的数字)也是设计计算机时人为规定的.
//
//     +1111 1111 (-1的二进制数补码,非机器数-1补码) 
//     取余位后的结果与(0000 0010 - 0000 0001结果相同,同余式)
//     1111 1111 数学意义上它是0000 0001补码(设计计算机电路时用1111 1111代表机器数-1补码)
//     所以符号位不变,余位取反+1这个转换规则并不是数学意义上的转换,而是人为规定的,实际的二进制数并没有所谓符号位
//     只是在计算机电路中这样转换得到机器数规定的-1补码,计算机中负数都以补码储存
//     十进制表述运算就是: 任何数-1(数学意义上的原码)等于任何数+1(数学意义上补码),取余位结果相同
//1.被减数大于等于减数绝对值,运算后直接得到结果
//2.被减数小于减数,运算后得到结果的补数
//数学运算时负数结果有负数符号,但机器数没有+-符号,而是用最高位表示符号位
//所以结果最高位为0,计算机就判定结果为正,最高位为1则判定结果为负数的，且为补码，得到正确结果还要
//根据机器数的补码转换规则转换成原码(所以才会有符号位不变,余位取反加1这种非数学意义上的补码转换规则。。。)
//-----------------------------------------------------------------------------------
// 补码    用补码代表相应的有符号整数
// 011               3
// 010               2
// 001               1
// 000               0
// 111              -1
// 110              -2
// 101              -3
// 100              -4
// mod模1000,减001等于加它的补码111,先别管它在计算机中所代表的的有符号整数
// 计算机设计中规定的,用001表示+1,第一位符号位0表示正;用001的补码111表示-1,符号位1表示负
// 
//再往下深究在计算机中具体怎么实现就要到数字电路了,差不多得了--',以后有时间再深入理解...
//
//===================================================================================
//看来一堆资料后,最具象化,最简单的理解来了!!!不需要公式！！！
//计算机的字长是固定的,可以把计算机看成是一个计量器,
//比如说钟表就是一个计量器,钟表是对时间的计量,钟表上的计量值是有限的，所以进行的是模运算，模为12(这里只考虑整点值)
//再引申到计算机,假设非负整数n为字长,则计算机的模为2^n
//再拿钟表来理解,日常接触的东西,更容易理解,原理都是一样的
//比如说现在指针指向1点(现在是凌晨1点),然后+1(也就是顺时针转1格,顺时针计量值越来越大,所以是加法)
//然后指针指向2, 1+1=2
//也可以时光倒流,回到3个小时前(也就是-3,计量器逆时针转,往计量值越来越小的方向转,当然转回上一个模时计量值会重置为最大值),
//然后指针指向了10,不能理解得话就这样想,凌晨1点,时光倒流3小时,不就是前天10点吗(这是指针是指向计量值10)
//这里转折来了,我们可以把这个钟表计量器改良一下,改成计量值[0,15],相当于n=4,
//用计量值[0,7]代表非负整数[0,7];
//用计量值[8,15]代表负整数[-8,-1];
//(其实你可以用计量值代表任何数字,字母,表情符等,任何东西都行,只要你想得到的,十二生肖也行,这并不影响模和计量值的计算)
//接着上面,1-3,指针指向计量值14,而我们刚刚用计量值14代表负整数-2,所以得到结果-2
//参与运算的数和结果不能超过我们所规定的范围,否则会出现溢出,大于所代表的最大值,则正溢出,小于所代表的最小值则负溢出.
//n=2,取值范围[-2,1],计算机大部分才有补码方式储存数据,像下面那样:
//         00  01  10  11  
//         0   +1  -2  -1
//1+1=2,超出取值范围,正溢出,(01)+(1)2=(10)2,计量值10在该例子中表示-2
//-2-1=-3,(10)2-(1)2=(01)2,计量值01代表+1,当然,真实的计算机运算中机器码是以补码相加来进行运算的,计算机只有加法器
//实际上就是模2^n的加减法运算,这个知识点还没看。。。第二天再看。。。准备睡觉
//然而事情并没有这么简单。。。补码的数学原理还要去啃一下《深入理解计算机系统》(原书第三版),呜呜呜~要崩溃了。。。--·
//
//===================================================================================
//《深入理解计算机系统》(原书第三版) 第二章 2.2 整数表示,看完了对计算机数据的存储理解更深入了
//学习还是要找对书啊~
//向量:有大小和方向
//bit vector(位向量)
//∑(求和符号,读音为sigma)
//负权值(负权重,negative weight) 
//w=2,补码(二补数two's complement)  B2T(11) = 1*(-2^1) + 1*2^0 = -1
//权值(权重weight value): 权值为负怎么理解呢
//附加知识点：十进制也好,二进制也罢,本质都是{计数系统},混合进制计数系统也是可以的,
//           例如,111,数位0,2为十进制,数位1为八进制. 则它们的权值为[1,10,80]
//我个人的理解->有两个人,拥有1块钱的有一人,欠债2块钱的有一人,补码11,数位0的权值为1,数位1的权值为-2,
//所以他们一共有多少钱?有上面B2T(11)函数可得结果
//
//unsigned encodings 无符号数编码
//原码(sign符号 magnitude大小) 补码(two's complement) 反码(one's complement) 都是机器数,
//机器数所对应的真正数值,称真值
//
// binary    unsigned    sign magnitude    one's complement    two's complement
//  000        0               0                0                   0
//  001        1               1                1                   1
//  010        2               2                2                   2
//  011        3               3                3                   3
//  100        4              -0               -3                  -4
//  101        5              -1               -2                  -3
//  110        6              -2               -1                  -2
//  111        7              -3               -0                  -1
//
//*补数加减法核心知识点(武林神功之一啊)
//附注: 10补数,9补数 2补数(two's complement),1补数(one's complement)的概念,知乎收藏夹[数字电路设计-第二讲]
//      理解末端进位,可以判断 被减数和减数 之间的大小
//      十进制:9补数,10补数
//      二进制:1补数,2补数
//      20191227个人理解: 9补数,让每一位值都变成9,比如333,求它的9补数,333+666=999,让每一数位值都为9
//                       999再加1,每一位都满10进1,所以333的10补数是667,这就是所谓的10补数
//      需特别注意:0的10补数是0,而不是套公式所得到的值,因为计算机中w位数截断(计算机中这个没错,但从数学上讲,这个有疑问,待确认)
//                5的10补数是5,50的十补数是50
//                two's complement 001和111为一对二补数,分别映射有符号整数1和-1
//      20191229 继续啃十补数,十补数的减法运算(二补数原理也是相同的)
//        被减数和减数数位不同时,取补数时位数以位数长的为准
//        设被减数为m,减数为n,w以参与运算的数中数位最长的为准
//       A.m,n为正数,减数为负数的话,-(-n)=+n,无讨论意义:(20200101补充)
//        m-n ---> m + (10^w - n) = m - n + 10^w
//        1) 如果 m ≥ n, m-n≥0,则减去10^w就可得到正确结果(模除效果也一样,模为10^w)
//        2) 如果 m < n, m-n<0,则再求补数, 10^w - (m - n + 10^w) = -m + n = n-m(这里模除,模为10^w,结果也是还n-m)
//           -->加符号 -(n-m)得到正确结果       
//        举例: m≥n:
//                010-001 ---> 010-001+1000 = 001 + 1000 = 1001 -->1000就是所谓的溢出部分,减去即可(模除1000结果一致)
//              m<n:
//                001-010 ---> 001-010+1000 = -001+1000 = 1000 - 001(得到001的2补数)= 111
//                111求-001这个正确结果: 先求10补数-->001,再加上负号-001。。。OK!打完收工
//       B.m为负数,n为正数,因为n为负数的话,-(-n)=+n就没有讨论的意义了,:(20200101补充)
//        举例: -4-2=-6 --> 6+8 = (10-4)+(10-2) = (-4-2)+10+10 = 4 + 10
//             减去10--十补数之和(模除10效果一样)后再求十补数加负号才得到正确结果
//        -001-001 --> 111+111=1110  1110-1000(1110 mod 1000)=110  110十补数=010 --加负号-> -010 (十进制-2)
//
//  *处理器提供了一套它能支持的运算操作集合,称为指令集.
//   输入程序和数据:1+2 --> 计算机中:001+010=011 -->输出:3
//   输入程序和数据:7+7 --> 计算机中(设w=3):111+111=1(110) -->110-->输出:6 (溢出)
//                                                          |--->计算机 数据+指令得到的数据,映射到什么值与它无关
//
//  additive inverse:加法逆元(或称相反数),对于任意一个数n,n和其加法逆元之和为加法单位元(即为零)
//      例如: 7的加法逆元为-7,-0.5的加法逆元为0.5
//      -(-x)为什么等于x:x+(-x)=0=(-x)+x,-x为x的加法逆元,x也是-x的加法逆元,-(-x)为-x的加法逆元等于x
//                      x加上它的相反数-x等于0,-x加上它的相反数-(-x)等于0,因此-(-x)=x
//  加法单位元:在加法运算的集合中,加法单元位加上集合内的任何一个数x,和都会等于这个数x.
//      例如: x+0=x=0+x
//  乘法逆元:在实数范围内, x * 1/x =1,x和1/x互为乘法逆元(x不可能为0,因为1/0无意义),乘法单位元为1.
//            x *  1/x = 1;
//           -x * -1/x = 1;
//
//20191214暂时小结
//     (以这个小结的为准,
//     之前的笔记因为个人理解不到位,还有国内课程教材真的不行啊...
//     英文原版>国内翻译>国内教材。。。
//     以看了国外书籍后的理解为准,毕竟这玩意别人才是原创...):
//     
//     位向量(bit vector) --(函数function)[映射map]--> 真值    (位向量和真值一一对应,唯一性)
//     
//     sign magnitude(符号+大小,国内所谓的原码,这翻译不直观):
//        真值encode成sign magnitude--映射-->位向量,反之,位向量=sign magnitude--[映射]-->真值
//     
//     one's complement(国内译反码现在的机器基本都用two's complement了,这里就不展开了,理解什么是9补数和1补数就行了)
//
//     two's complement(二补数,国内译补码):
//        真值encode成two's complement--映射-->位向量,反之,位向量=two's complement--[映射]-->真值
//        two's complement 001和111互为二补数,分别映射有符号整数1和-1
//
//     two's complemnt的加减法,本质就是位向量的模运算(详情阅读上面模运算的笔记)
//        二补数(补码)的运算结果正确,是位向量模运算后的余数映射到的真值结果与真值运算的结果相同,
//        当然前提是参与运算的数和结果要在补码映射的范围内,不然发生溢出,结果错误
//
//===================================================================================
//20191222 继续啃《深入理解计算机系统第三版》 P60 整数运算
// 无符号数加法(unsigned addition):----------------------------------------------------------start
//    取值范围: 0 <= x,y < 2^w
//    w位无符号数加法运算: 0 <= x+y < 2^w + 2^w
//                        0 <= x+y < 2 * 2^w
//                        0 <= x+y < 2^w+1       其实x+y实际小于2^w -1,因为x+y最大只能到2^w -2
//
//   假设w=3   0 <= x,y < 2^w --> 0 <= x,y < 2^3 --> 0 <= x,y < 8
//             0 <= x+y < 2^3 + 2^3 -1 = 2*2^3 -1 = 2*8-1 --> x,y取最大值, 7+7 < 15
//                                             or = 2^(3+1) -1 = 2^4 -1
//             二进制表示: x_max + y_max =111+111=1110 < 10000(d:2^w+1=2^3+1) -1=1111 
//
//  *无符号加法的核心知识点,无符号数加法的溢出检测:
//    s=x+y >= x,则没有溢出
//    如果结果溢出了,s=x+y-2^w=x+(y-2^w), 由上我们已知y<2^w,所以y-2^w<0
//             所以 s=x+(y-2^w) < x
//    推导出结论: s>x,没有溢出; s<x,溢出
//
// 取模运算: 10 mod 2=0(10对2取模,等于10除于2的余数)
//                   05 商
//               2   10       十位的1捆(10根/捆)辣条不够分成两捆
//                   10       把十位的1捆拆散成10根放到个位
//                   10       10根可以分成两份,5根一份(商)
//                    0 余    余数为0
//           1 mod 10(1对10取模)
//                    0 商
//               10   1
//                    1 余
//                             +u/w w位无符号数加法(和模2^w,可以被视为一种形式的模运算)
//w(word)     s(sum)           u(unsigned)/w(word)                            x,y=[0,2^w -1]
//  w=3   s=x+y=[0,2^w+1 -2]   s=x +u/w y=x+y mod 2^w(x+y对2^w取模)
//            1(110) -------                         (x+y除于2^w的余数)
//            1(101)       |
//            1(100)       |
//            1(011)     map3
//            1(010)       |
//            1(001)       |
//            1(000)-map1--|
//              111--map2--|--map2-> 111                                            111
//              110        |--map3-> 110                                            110        
//              101        |         101                                            101
//              100        |         100                                            100          
//              011       map1       011                                            011
//              010        |         010                                            010
//              001        |         001                                            001
//              000--map0--|-map0&1->000                                            000
//  x+y --映射(这里map short for mapper,map:地图)--> x +u/w y
//  s(sum)列中末端进位的数值就是溢出的s
//加法逆元(或称 相反数): 例如, 7的加法逆元是-7
//*unsigned encode无符号整数编码的本质: 一个数的十进制转换成二进制,这个二进制的位表示就是这个数的无符号整数编码
//   十进制数2和3,用2位二进制编码(无符号整数编码)表示,分别是[10],[11]
//   2+3的和等于5,用二进制编码表示是[101],这里机器位数2位,丢弃最高位,我们得到位表示[01],映射十进制值1
//   结果与 binary:101 mod 100 = 01   decimal:5 mod 4 = 1  模除结果一致
//   B2U本质就是一个数的二进制转十进制: B2U[111] = 1*2^2 + 1*2^1 + 1*2^0   B2U[100] = 1*2^2 + 0*2^1 + 0*2^0
//                                   B2U[111-100] = 1*2^2 + 1*2^1 + 1*2^0 - (1*2^2 + 0*2^1 + 0*2^0)
//                                   B2U[11] = 1*2^1 + 1*2^0
//                                     |--> bianry: 11
//   [辣条,辣条,辣条]的数量--位置计数法--|                     (两个数字表示的辣条数量都是一致的)
//                                     |--> decimal: 3
//
// 二补数加法(two's complement addition)---------------------------------------------------start
// 预备数学知识: start
//  下面三个指数幂统称整数指数幂
//  正整数指数幂的定义: w个2相乘的积记作2^w,称为2的w次幂
//  负整数指数幂的定义: 负指数幂等于把幂指数变号后所得的幂的倒数  2^-w = 1/2^w
//  零指数幂(底数为非零整数,因为除数不能为0,0作除数毫无意义): 
//         2^w/2^w=1  2^w *1/2^w=1  2^w*2^-w =1  2^(w-w)=1  2*2*2/2*2*2=1(除于一次2相当于分母的幂指数减一次1,w-1)
//         2^0=1
//
//  2*2^(w-1)=2^1 * 2^(w-1) 
//           =2^1+w-1 = 2^w
//  2^w/2^1=2^(w-1) 就是w个2相乘,除于2,不就还剩w-1个2相乘
//         =2^w * 1/2^1    1/2^1符合2^-1的定义
//         =2^w * 2^-1 =第一行的结果
//  *个人见解:为什么把2^-w定义为1/2^w幂指数变号得到的幂的倒数
//   2^3=2*2*2
//   2^3 *2=2^3 *2^1=2*2*2*2=2^4
//   2^3/2^1=2^3 *1/2^1=2*2*2/2=2^2=2^(3-1)  -->所以定义 1/2^1=2^-1 (*2^1增加两倍,*2^-1刚好缩小两倍)
//                                              这样正整数指数幂和负整数指数幂作用刚好相反
//   英文定义感觉更容易理解:
//   The power (or exponent) of a number says how many times to use the number in a multiplication(乘法). 
//   A negative exponent means how many times to divide by the number   
//   
//  2^w   乘法: 2^a * 2^b-->2^(a+b)
//        除法: 2^a/2^b-->2^(a-b)
//        举例: 2^3 * 2^2 = 2*2*2 * 2*2 = 2^5 = 2^(3+2)
//              2^3 / 2^2 = 2*2*2 / 2*2 =2 8分成4份,1/4四分之一份等于2 
//                        = 2^1 = 2^(3-2)
//              2*2*2 / 2*2 = 2*2*2 * 1/(2*2)
//  *数学乘除法的精髓,升华人生的知识点,理解完感觉自己飞升进入新境界了--' ...:
//      除法的本质,分成相同的份数(有存在余数的情况)
//      除法竖式的本质:(没有什么是一根辣条不能解决的,如果不能,那就一捆...)
//                   63.5
//              2   127.0   桌子2:1捆辣条(100根/捆) 桌子1:2捆辣条(10根/捆) 桌子0:7根辣条
//                  12     1.桌子2:1捆辣条(100根),没法分成两捆了(100根/捆),拆散分成10小捆(10根/捆)放到桌子1,
//                    7    2.桌子1:现在有12捆(10根/捆),分成2份,每份6捆
//                    6    3.桌子0:7根辣条,分成两份,每份3根,余1根,1根用刀分成10份,放到桌子-1
//                    10   4.桌子-1:10份(1份/0.1根),再平均分成两份,变成5份
//                    10
//                     0  
//      乘法的本质,将相同的数加起来的快捷方式,运算结果成为积,从哲学角度讲,乘法是加法由量变到质变的结果
//
//*武林绝学知识点之一,二补数转无符号数 和 无符号数转二补数的本质:
//        -->       w-1
// B2U(w)[ x 位向量]= ∑ x(i) * 2^i
//                i=0
//        -->                         w-2
// B2T(w)[ x 位向量]= x(w-1)*-2^(w-1) + ∑ x(i) * 2^i
//                                    i=0
//        -->
//  binary(x)  two's complement(x)   unsigned(x)       
//    [011]            3                  3
//    [010]            2                  2
//    [001]            1                  1
//    [000]            0                  0
//    [111]           -1                  7
//    [110]           -2                  6
//    [101]           -3                  5 
//    [100]           -4                  4
// 通过观察上表的规律,B2U和B2T两个函数(function),T2U 和 u2T 的推导:
// 这里的_w是指下标w,表示字长   
//             |----> = x (x>=0)  这里的x是指二补数的x
//   T2U_w(x) -| 
//             |----> = x + 2^w (x<0)
//  1. x>=0的情况比较直观,直接看B2U和B2T两个函数就可以直接看出,
//     输入相同编码(位向量),在xi=x(w-1)=0时(也就是无符号数编码和二补数编码最高位为0时),
//     函数输出的结果是一样的,所以映射到的真值相等
//  2. x<0的情况,
//     输入相同编码,在xi=x(w-1)=1时,
//     B2U B2T 输出结果 只有x(w-1)位的位权是不同的,余下的数位 数值和位权都一致,所以结果也是一致的
//             无符号编码: x(w-1)位位权  2^(w-1)
//             二补数编码: x(w-1)位位权 -2^(w-1)     
//     所以T2U(x),只要 -2^(w-1) + 2^w                 +剩下的位*位权之和 (无符号和二补数的和都一样)
//                    = -2^(w-1) + 2*2^(w-1)         +剩下的位*位权之和  
//                    = -2^(w-1) + 2^(w-1) + 2^(w-1) +剩下的位*位权之和 
//                    = 2^(w-1)                      +剩下的位*位权之和  
//                                     -->        -->
// U2T原理跟上面的T2U是一样的,这里就不详细展开了(要详细了解可以看《深入理解计算机系统第三版》P51):
//  1. x(unsigned)<=x(T's_c_max),B2U(w)[x]和B2T(w)[x]映射到的真值x是相等的
//  2. x(unsigned)>x(T's_c_max),理解的关键点:2^(w-1) - 2^(w-1) -2^(w-1)
//                                          =2^(w-1) - 2*2^(w-1)
//                                          =2^(w-1) - 2^w
//
//二补数加法(two's-complement addition)
//  w位二进制位置计数系统,有2^w种组合方式,平分成两组,2^w/2=2^w * 2^-1=2^(w-1),
//  一半代表非负数(非负数还要有一个组合代表0),一半代表负数,得到如下取值范围,
//  取值范围: -2^w-1 <= x,y <= 2^w-1 -1
//  它们的和: -2^w-1 + -2^w-1 <= x+y <= 2^w-1 -1 + 2^w-1 -1
//  
// 对取模运算(这里暂时主要讨论整数的取模运算)做个小小的了结:
//  注: modulo(模数) division(分裂,除法) modulo division(模除法) division operation(除法运算)
//      multiplication(乘法)
//  modulo operation(模除,取模操作,取模运算):模除得到的是一个数除以另一个数的余数.
//  给定两个正整数:被除数a和除数n, a modulo n(缩写为a mod n)得到的是使用欧几里德除法(带余除法)时a/n的余数
//  通常情况下a和n都是整数(对实数,浮点数取模也是可以的,这里暂时不讨论),余数r的取值范围[0,n-1],
//  a mod 1恒等于0(a/1,除法本质:/1分成1份,肯定等于这个数本身啊,也肯定不存在余数啊,所以恒=0),a mod 0未定义
//  
//       (110)
//       (101)
//       (100)        
//        011
//        010
//        001
//        000
//        111
//        110
//        101
//        100
//      1(011)
//      1(010)
//      1(001)
//      1(000)
//
//======================================================================================================
//20200103 真值与编码之间的数学原理的个人的一点理解:
//20200105 囧 越写越长了。。。以最新写的为准,越往下越新...
//二补数编码(two's complement encode)
//
//       二补数编码          十进制真值    二进制真值
//  w=3  011       --map-->     3     =   011
//       100       --map-->    -4     =  -100
//
//  binary(真值)                                                    decimal(真值)
//   -100 + -100                                                  = -4 + -4        真值的运算
// = -1000
//
//  (1000-100)+(1000-100) = 100 + 100 (二补数+二补数) -->把减法转换成二补数的加法来运算求结果
// = -100 + -100 + 1000 + 1000 
// = -1000 + 1000 + 1000              (-1000为 -100 + -100 的正确运算结果)
// = -1000 + 10000     
// =  1000                            (1000为减法运算正确结果的绝对值的二补数)
// =   000 + 1000
//   1000(减法转换为二补数加法运算后得到的结果)
//   --> 1000的二补数是1000                               1000 + 1000 = 1 0000(二补数之和)
//   --> 再加上负号= -1000,得到减法运算的正确结果
//这是补数运算的数学原理
//
//上面的例子在计算机中的运算
//  直接看上例中这一步: = 000 + 1000 = 1000
//  因为计算机的计算数位位数是有限的,这里假设字长w=3,计算机只保留结果最后3位,相当于截断了结果1000
//  计算机中得到的运算结果是000,相当于1000 mod 1000 = 000(000和0是一样的)
//  所以计算机运算得到的这个例子的结果并不是 真值运算结果的绝对值的二补数,
//  因此最后用B2T函数映射到了一个错误的真值(即所谓的溢出)
//  1000二补数编码被截断了最高位,最高位为负位权,相当于要减去一个数得到运算结果,
//  现在舍去了这一位,运算结果再加上这个数就得到舍去最高位后的映射结果
//
//理解的关键点: 计算机运算的截断相当于数学中的模除(modulo)
//             -001的二补数编码就是该数的绝对值的二补数,即001的二补数111
//             减法转二补数加法运算,从运算过程可以看出,结果由三部分组成:
//
//              1) 被减数为非负数(减数为非负数,减去一个负数等于加上这个数,就没讨论意义了):
//                 真值运算结果 + 减数的绝对值和其绝对值的二补数之和
//
//                    1.1) 如果真值运算结果大于等于0,则直接得到结果(二补数编码中,正整数的编码其实就是其二进制数),
//                         因为被计算机运算舍去最高位(截断结果)相当于模除了减数的绝对值和其绝对值的二补数之和
//                         (计算机中参与运算的两个数数值位数肯定是相同的,位数不足的也会填充到位数相等,
//                          二补数之和肯定是会末端进位的)
//                    1.2) 如果真值运算结果小于0,则得到结果是这个负数真值运算结果的绝对值的二补数
//                         因此得到的结果是负数真值结果的二补数,通过函数B2T可以直接映射到正确的真值结果
//                         (二补数编码,负整数的编码本质就是其绝对值的二补数,二进制数)
//                         例如: w=3  真值结果= -001
//                                    则计算机运算结果= 111, 111就是-001的二补数编码
//                                    B2T(111)=(这里省略计算的公式) -001 = -1
//                         
//             2) 被减数为负数:
//                真值运算结果 +  被减数的绝对值和其绝对值的二补数之和 + 减数的绝对值和其绝对值的二补数之和
//                (因为计算机中参与运算的数的数值位数相同,
//                 因此 被减数的绝对值和其绝对值的二补数之和 = 减数的绝对值和其绝对值的二补数之和)
//                 得到 负数真值结果的二补数 + 被减数或减数的绝对值和其绝对值的二补数之和
//                 被减数或减数的绝对值和其绝对值的二补数之和(计算机截断结果相当于模除掉这部分)
//                 = 负数真值结果的绝对值的二补数(也是负数真值结果的二补数编码)
//                 在计算机中这个二补数编码 --映射--> 负数真值结果
//                 w=3        -001 + -001 = -010, |-010|=010
//                二补数运算:   111 +  111           = 1110  
//                           = 1000-001 + 1000-001 
//                           = 1 0000 - 010
//                           001的二补数 + 001的二补数 = 010的二补数,所以二补数运算的结果等于负数真值运算结果的绝对值的二补数
//20200105主要看下面这一段就行了:
//  二补数运算举例: 
//    1) 计算机:
//     -100 + -100 + -100
//      101 +  100                (先计算前面两个) 
//    = 1000 - 100 + 1000 - 100
//    = -1000 + 10000             (-100 + -100 = -1000)
//    =  1000                     (-1000的4位二补数,也是-1000在计算机中的二补数编码,这里假设字长w=3)
//  w=3,这里截断数位,结果=000
//     000 + 100
//   = 000 + 1000 + -100
//   = 000 + 100
//   = 100  B2T--map--> -4
//  所以计算机中: -4 + -4 + -4 = -4-4-4 运行结果= -4
//
// 如果字长w不受限制,是可以计算出正确结果的:
//    -100 + -100 + -100
//     100 +  100                (先计算前面两个)
//  =  1000 - 100 + 1000 - 100
//  = -1000 + 10000             (-100 + -100 = -1000)
//  =  1000                     (-1000的4位二补数,也是-1000在计算机中的二补数编码,这里假设字长w=3)
//  
//    -1000 + -0100 = -1100
//  =  1000 +  1100
//  =  10000 - 1000 + 10000 - 0100
//  =  -1100 + 100000 
//  = -01100 + 100000 
//  =  10100 B2T--map--> (-12)10 (-01100)2=(-1100)2                        
//  (10100为-1100的5位二补数,也是-1100在计算机中的二补数编码,计算机中w至少5位才能存储真值-1100)  
//  (负数在计算机中都是以二补数编码储存的)                   
//
// decimal |  binary  | unsigned encode | two's complement encode 
//    7        111          111                  0111
//   -7       -111           -                   1001
//   -8      -1000           -                   1000
//二补数编码比二进制数字长(数位)多一位才能储存这个二进制数
//注:1000属于特殊情况,1000的4位(w=4)二补数位就是1000
// 1111的二补数编码01111
//-1111的二补数编码,编码过程: 
// -01111 --> |-01111| --> 01111 --> 10000(一补数) --> 10001(二补数)
//
//无符号编码: 7 -->  111 --> 111
//          -7 --> -111 -->  -
//
//通过十补数运算来理解-->计算机中的二补数运算
//(原理一样,但二进制数运算有其特殊性,计算机中算法也有其特殊性):
//  9 - 4 = 09 - 04 (等价于09 + -04) = 05
// --> 减法转十补数加法运算(计算机运用的十补数加法运算,数学中并不需要这样算) 
// --> 09 + 96 
//   = 09 + 100 - 04 
//   = 09 - 04 + 100 
//   = 05 + 100 
//   = 105            
// --> 105减去溢出部分100(与105mod100结果一样)
// --> 得到正确结果05 
//
// 4 - 9 = 04 - 09(等价于04 + -09) = -05
// --> 04 + 91
//   = 04 + 100 - 09
//   = 04 - 09 + 100
//   = -05 + 100
//   =  95            (95为05的二位十补数)
// --> 求95的二位十补数,得到05
// --> 再加上负号,得到正确结果 -05   
//
// -3-1 = -03-01(等价于-03 + -01)
// --> 97 + 99
//   = 100 - 03 + 100 - 01
//   = -04 + 100 + 100
//   = 96 + 100
//   = 196
// --> w=2,舍去最高位,截断结果(196 mod 100等效)
// --> 再求96的二位二补数,加负号,得到正确结果
//
// -4-4 = -04-04(等价于-04 + -04) = -08
// --> 96 + 96
//   = 100 - 04 + 100 -04
//   = -08 + 100 + 100
//   =  92 + 100
//   = 192                   (舍去最高位,截断结果,再求2位十补数加负号,得到结果-08)
//
//*发生溢出是因为字长有限,字长不受限制的话减法转十补数/二补数的加法是永远可以得到正确结果的
// 真值结果非负数,补数运算结果就模除得到正确结果,真值结果为负数,补数运算结果就求相同数位补数再加负号即可得到正确结果
//======================================================================================================
void limits_head_constants(void); //函数声明,function declaration
void unsigned_int_operation(void);
void integer_multiplication(void);//multiplication乘法
void a_modulo_n(void);
void integer_constants_limits(void);

int main(void)
{
    short int  x,s,a = 6,b = -7;
    unsigned short int i;
    char c;
    
    s = a + b;

    printf("s=a+b = %hd\n", s);
    printf("s=a+b = %hx\n", s);
    printf("s=a+b = %hx\n", a + b);
    printf("size of i:%d\n", sizeof(i));
    printf("s=a+b = %hu\n", a + b);
    //整数常量255 4byte 0000 0000 0000 0000 0000 0000 1111 1111
    //赋值给char 1111 1111(只保留最后1byte)是负数-1的补码 
    //转换说明 short int 1111 1111 1111 1111 负数填充1111 1111
    printf("%hd %hx\t %hx %hx\n", c = 255, c = 255, x = -255, -255);
    //0111 1111 整数填充 0000 0000 0111 1111 前面填充0000 0000
    printf("%hd\v %hx\n", c = 127, c = 127);
    printf("%hd\n", x = 32768); 
    printf("\x41 \077\n"); //转移序列 \xhh十六进制
    printf("what is you name\" \n");
    printf("%hx\n", 1-2);
    printf("4294967295 hexadecimal: %x,decimal: %u\n", 4294967295, 4294967295);
    //decimal(4294967296): 1 0000 0000 0000 0000 0000 0000 0000 0000
    //int constant 4byte:    0000 0000 0000 0000 0000 0000 0000 0000
    // --> printf --> 0
    printf("4294967296 hexadecimal: %x,decimal: %u\n", 4294967296, 4294967296);
    //decimal(-4294967296): - 1 0000 0000 0000 0000 0000 0000 0000 0000
    //two's complement:       1 0000 0000 0000 0000 0000 0000 0000 0000
    //int constant 4byte:       0000 0000 0000 0000 0000 0000 0000 0000
    // --> printf --> 0
    //*注:-1000类型的负数的二补数编码属于特殊情况,其它都是二补数编码比真值数码多一位储存
    printf("-4294967296 decimal: %u\n", -4294967296);
    //decimal(-4294967295): - 1111 1111 1111 1111 1111 1111 1111 1111
    // --> 二补数编码储存:   - 1111 1111 1111 1111 1111 1111 1111 1111 
    // --> 需要33bit:     - 0 1111 1111 1111 1111 1111 1111 1111 1111
    //two's complement:     1 0000 0000 0000 0000 0000 0000 0000 0001
    //整数常量4byte:           0000 0000 0000 0000 0000 0000 0000 0001
    // --> printf --> 1
    printf("-4294967295 decimal: %d, unsigned: %u\n", -4294967295, -4294967295);
    
    limits_head_constants();
    unsigned_int_operation();
    integer_multiplication();
    a_modulo_n();
    integer_constants_limits();
    return 0;
}

void limits_head_constants(void)
{
    printf("int Max:%d\n", INT_MAX);
    printf("int Min:%d\n", INT_MIN);
    printf("unsigned int Max:%u\n", UINT_MAX);
    printf("long Max:%ld\n", LONG_MAX);
    printf("long Min:%ld\n", LONG_MIN);
    /*
    mingw compiler
    printf("long long Max:%lld\n", LONG_LONG_MAX);
    printf("long long Min(hexadecimal):%llx\n", LONG_LONG_MIN);
    printf("unsigned long long Max:%llu\n", ULONG_LONG_MAX);
    */
    //cygwin gcc
    printf("long long Max:%lld\n", LLONG_MAX);
    printf("long long Min(hexadecimal):%lld\n", LLONG_MIN);
    printf("long long Min(hexadecimal):%llx\n", LLONG_MIN);
    return;
}

void unsigned_int_operation(void)
{
    short unsigned int us1 = 10, us2 = 20, result;
    //无符号数一般不这样用,这里只是验证一下无符号数的编码储存
    result = us1 - us2; 
    //本质是位向量的运算(bit vector),加上模和补数的知识,转换说明相当于"function",最后得到(映射到真值)结果,
    //映射到啥就是啥了~ 

    //数学术语双射,《深入理解计算机系统》(原书第三版)P44 无符号数编码,补码编码的唯一性
    //个人心得:w(字长:计算机分配的数据存储长度)一样的情况下,binary都一样,只是映射到不同的真值,
    //         映射到unsigned,反射回binary,这个binary就是unsigned encodings；
    //         映射到two's complement number，反射回binary,这个binary就是补码编码
    //注:个人心得未必正确,只是目前个人的理解.

    //B2U[w](x:bit vector) {二进制数binary to 无符号数编码unsigned encodings} =映射--> 无符号整数(真值)
    //U2B[w](x:decimal value) {二补数(补码)two's complement to 二进制数binary } =反射--> 二进制数(补码表示)

    //B2T[w](x:bit vector) {二进制数binary to 二补数(补码)two's complement} =映射--> 有符号整数(真值)
    //T2B[w](x:decimal value) {二补数(补码)two's complement to 二进制数binary } =反射--> 二进制数(补码表示)
    printf("Wrong result:%hu,Right result:%hd,Right result:%hu\n", result, result, us1 + us2);
    return;
}

void integer_multiplication(void)
{
    short int a=2, b=6, c=16384, r;
    // short int 16384   binary: 0100000000000000         
    //                         * 0000000000000010
    //                           0000000000000000
    //                          0100000000000000
    //                          01000000000000000
    //                    w=16   1000000000000000 (结果为0100000000000000像左移一位)
    printf("2*6=%hi,overflow:2*16384=%hi\n", r=a*b, r=c*a);
    return;
}

void a_modulo_n(void)
{
    short unsigned int a=11, n=2;
    // %操作符为整数取模,fmod()函数包含在math.h里,浮点数取模
    // (short int)1 对整型常量进行强制类型转换
    printf("a mod n = %hu, a mod 1 =%hu\n",a%n, a%(short int)1);
    printf("sizeof((short unsigned int)1): %d\n", sizeof((short unsigned int)1));
    printf("sizeof(a*(short unsigned int)1):%d\n", sizeof(a*(short unsigned int)1));
    printf("sizeof(a*n): %d\n", sizeof(a*n));
    return;
}

void integer_constants_limits(void)
{
    long long int lli1 = 9223372036854775807; /*lli2 = -9223372036854775808*/
    //备忘:test2.c是在Linux系统下写的。。。
    //c标准规定long int型大于等于int,存储字长看编译系统(4byte\8byte)
    //整数常量作为有符号整数编码,即用二补数编码储存
    //储存长度是可变的,4byte和8byte两种字长(gcc编译系统的原因)
    //clang编译系统使用64为绝对地址储存整数常量
    //C语言标准,C编译器也还是在不断发展的,目前clang和gcc为主流
    //写C还是用linux比较好,编译系统比较新
    //4byte[-2^31,2^31-1], 8byte[-2^63,2^63-1]
    printf("sizeof(long long int):%d\n",sizeof(lli1));
    printf("sizeof(2147483647):%d\n", sizeof(2147483647));
    printf("sizeof(2147483648):%d\n", sizeof(2147483648));
    printf("sizeof(4294967296):%d\n", sizeof(4294967296));
    printf("sizeof(9223372036854775807):%d\n", sizeof(9223372036854775807));
    //溢出:printf("sizeof(9223372036854775808):%d\n", sizeof(9223372036854775808));
    //printf--> -1 现在用的编译系统的问题,long int和int都是32bit,%ld跟%d一样...
    printf("9223372036854775807 d:%d\n", 9223372036854775807);
    printf("9223372036854775807 ld:%ld\n", 9223372036854775807);
    printf("9223372036854775807 lld:%lld\n", 9223372036854775807);
    //printf("sizeof(9223372036854775808) lld:%lld\n", 9223372036854775808);
    //编译时报错,整数常量字长最长为64bit,
    //0111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111
    //最大有符号整数
    printf("-9223372036854775807 lld:%lld\n", -9223372036854775807);
    printf("-9223372036854775807 llx:%llx\n", -9223372036854775807);
    /*
        <limits.h>  long long int 最小值的定义
        # define LLONG_MIN (-LLONG_MAX - 1LL)
    */
    // long long int 最小值的正确输出方式:
    printf("-9223372036854775808 lld:%lld\n", -9223372036854775807-1);
    printf("-9223372036854775808 llx:%llx\n", -9223372036854775807-1);
    printf("9223372036854775808u llu:%llu\n", 9223372036854775808u);
    return;
}



```




## 5.  数值计算 数学函数 计算
```c
#include <stdio.h>
// Floating-Point Operations 浮点数运算
//exponent指数 指数计数法:1.0e9
//             科学计数法:1.0*10^9
//                   数字:1000000000
void float_double_limits(void);
void float_double_addition(void);
void float_double_subtraction(void);
void float_double_multiplication(void);
void float_double_division(void);
void float_double_format_specific(void);

void main(void)
{
    float f1 = 111.111, fa = 1.4, fb = 0.1, \
    fc = 1.3999999, fd = 1.3999995, fe = 1.3999994;
    double dc = 1.3999999, dd = 1.3999995, de = 1.3999994;

    printf("f1(d):%d\n",f1);
    printf("sizeof(f1):%d\n", sizeof(f1));
    //format specific %f 默认保留小数点后六位
    //                %a float默认保留小数点后六位
    //                %a double默认保留小数点后十三位
    //double 即可用 %f 也可用 %lf
    printf("fa(f):%f\n", fa);
    printf("fb(f):%f\n\n", fb);
    printf("fc(f):%f, fc(a):%a\n", fc, fc);
    printf("fd(f):%f, fd(a):%a, fd(.7a):%.7a\n", fd, fd, fd);
    printf("fe(f):%f, fe(a):%a\n\n", fe, fe);
    //float double 格式说明符都是 %f
    printf("dc(f):%f, dc(a):%a, dc(.7a):%.7a\n", dc, dc, dc);
    printf("dd(f):%f, dd(lf):%lf, dd(a):%a, dd(.7a):%.7a\n", dd, dd, dd, dd);
    printf("de(f):%f, de(a):%a, de(.7a):%.7a\n\n", de, de, de);
    
    printf("fa(.10f):%.10f,fa(a):%a\n", fa, fa);
    printf("fb(.10f):%.10f,fb(a):%a\n", fb, fb);
    printf("fa(.6a):%.6a\n", fa);
    printf("fb(.6a):%.6a\n", fb);
    printf("\n");
    
    float_double_limits();
    float_double_addition();
    float_double_subtraction();
    float_double_multiplication();
    float_double_division();
    float_double_format_specific();
    return;
}

void float_double_limits(void)
{
    float fa = 1.3, fb = 1.1;
    double da = 1.3, db = 1.1;
    long double lda = 1.3;
    //float: 1 8 23; size: 32
    //double: 1 11 52; size: 64
    //long double: 1 
    printf("sizeof(fa):%d\n", sizeof(fa));
    printf("sizeof(da):%d\n", sizeof(da));
    printf("sizeof(lda):%d\n", sizeof(lda));
    printf("fb(.20a):  %.20a,\nfb(.40a):  %.40a\n", fb, fb);
    printf("db(.20a):  %.20a,\ndb(.40a):  %.40a\n", db, db);
    printf("fa(.20a):  %.20a,\nfa(.40a):  %.40a\n", fa, fa);
    printf("da(.20a):  %.20a,\nda(.40a):  %.40a\n", da, da);
    //%lf double; %Lf long double
    printf("lda(.60La):%.60La\n\n", lda);
    return;
}

void float_double_addition(void)
{ 
    float fa = 1.4, fb = 0.1;
    printf("fa + fb(float):%f,fa + fb(a): %a\n", fa + fb, fa + fb);
    printf("fa - fb(float):%f,fa + fb(a): %a\n", fa - fb, fa - fb);
    printf("fa + fb(.6a): %.6a\n", fa + fb);
    printf("fa + fb(.6a): %.6a\n\n", fa - fb);
    return;
    // float double addition:
    // 1.4 -->  
    //  整数部分:    2 | 1 --> 余 1
    //  小数部分:  0.4 * 2 = 0.8 --> 0
    //            0.8 * 2 = 1.6 --> 1
    //            0.6 * 2 = 1.2 --> 1
    //            0.2 * 2 = 0.4 --> 0
    //            0.4 * 2 = 0.8 --> 0
    //            0.8 * 2 = 1.6 --> 1
    //            0.6 * 2 = 1.2 --> 1
    //            0.2 * 2 = 0.4 --> 0
    //            0.4 * 2 = 0.8 --> 0
    //            0.8 * 2 = 1.6 --> 1
    //            0.6 * 2 = 1.2 --> 1
    //            0.2 * 2 = 0.4 --> 0
    //            0.4 * 2 = 0.8 --> 0
    //            0.8 * 2 = 1.6 --> 1
    //            0.6 * 2 = 1.2 --> 1
    //            0.2 * 2 = 0.4 --> 0
    //            0.4 * 2 = 0.8 --> 0
    //            0.8 * 2 = 1.6 --> 1
    //            0.6 * 2 = 1.2 --> 1
    //            0.2 * 2 = 0.4 --> 0
    //            0.4 * 2 = 0.8 --> 0
    //            0.8 * 2 = 1.6 --> 1
    //            0.6 * 2 = 1.2 --> 1
    //            0.2 * 2 = 0.4 --> 0 rounding
    // 1.4(binary): 1. 0110 0110 0110 0110 0110 011|0 * (2^0)10
    //              1.  6    6    6    6    6     6(rounding)    
    // S      E               M
    // 0  01111111  01100110011001100110011           
    //                              
    // 0.1 -->
    //  整数部分:   2 | 0 --> 余 0   
    //  小数部分:  0.1 * 2 = 0.2 --> 0
    //            0.2 * 2 = 0.4 --> 0
    //            0.4 * 2 = 0.8 --> 0
    //            0.8 * 2 = 1.6 --> 1
    //            0.6 * 2 = 1.2 --> 1
    //            0.2 * 2 = 0.4 --> 0
    //            0.4 * 2 = 0.8 --> 0
    //            0.8 * 2 = 1.6 --> 1
    //            0.6 * 2 = 1.2 --> 1
    //            0.2 * 2 = 0.4 --> 0
    //            0.4 * 2 = 0.8 --> 0
    //            0.8 * 2 = 1.6 --> 1
    //            0.6 * 2 = 1.2 --> 1
    //            0.2 * 2 = 0.4 --> 0
    //            0.4 * 2 = 0.8 --> 0
    //            0.8 * 2 = 1.6 --> 1
    //            0.6 * 2 = 1.2 --> 1
    //            0.2 * 2 = 0.4 --> 0
    //            0.4 * 2 = 0.8 --> 0
    //            0.8 * 2 = 1.6 --> 1
    //            0.6 * 2 = 1.2 --> 1
    //            0.2 * 2 = 0.4 --> 0
    //            0.4 * 2 = 0.8 --> 0
    //            0.8 * 2 = 1.6 --> 1
    //            0.6 * 2 = 1.2 --> 1
    //            0.2 * 2 = 0.4 --> 0
    //            0.4 * 2 = 0.8 --> 0
    //            0.8 * 2 = 1.6 --> 1
    //
    // 0.1(binary): 0.0001 1001 1001 1001 1001 100|11001 * (2^0)10
    //      规格化: 0 0001.10011001100110011001100|1 * (2^-4)10       
    //        -->       1.10011001100110011001100|1(rounding) * (2^-4)10
    //        -->       1. 1001 1001 1001 1001 1001 101|0(rounding) * (2^-4)10
    //                  1.  9    9    9    9    9    a  * (2^-4)10
    //                  1.  9    9    9    9    9    a  * (p^-4)10
    //
    // 1.4 + 0.1 =  1. 0110 0110 0110 0110 0110 011 * (2^0)10
    //              1. 1001 1001 1001 1001 1001 100 * (2^-4)10
    // 
    //提取(2^0)10,w字长有限,移位较小的浮点数确保结果准确度(移位阶码值小的)            
    //1. 0110 0110 0110 0110 0110 011 * (2^0)10 + 1. 1001 1001 1001 1001 1001 100 * (2^-4)10
    //[1. 0110 0110 0110 0110 0110 011  + 1. 1001 1001 1001 1001 1001 100 * (2^-4)10] * (2^0)10
    //[1. 0110 0110 0110 0110 0110 011  + 0. 0001 1001 1001 1001 1001 1001 100] * (2^0)10
    //
    //        1.01100110011001100110011
    //        0.000110011001100110011001(rounding)--|
    //        0.00011001100110011001101 <-----------|
    //        1.10000000000000000000000
}

void float_double_subtraction(void)
{
    //subtraction
    //减数与被减数都是负数,直接符号位不变,阶码转换成与阶码值大的一致,尾数做加法即可;
    //减数与被减数一正一负,阶码转换成与数值大的浮点数一致,
    //符号位以尾数值大的为准,尾数(大)-尾数(小)-->尾数(大)+尾数(小)的二补数:结果肯定溢出,舍掉溢出位即可
    //1.75 --> 1.11000000000000000000000 * (2^0)10
    //1.75 --> 0 01111111 11000000000000000000000 
    //         
    //0.625--> 0.10100000000000000000000 * (2^0)10
    //0.625--> 1.01000000000000000000000 * (2^-1)10
    //0.625--> 0 01111110 01000000000000000000000
    //
    //以阶码大的为准,阶码小的转换成阶码大的
    //1.75 --> 1.11000000000000000000000 * (2^0)10
    //0.625--> 1.01000000000000000000000 * (2^-1)10
    //0.625--> 0.10100000000000000000000 * (2^0)10  尾数变小,阶码变大
    //
    //   111000000000000000000000
    // - 010100000000000000000000 --->|
    //   101011111111111111111111 <---| one's complement
    // + 101100000000000000000000 <---| two's complement
    //----------------------------------
    //  1100100000000000000000000       截断最高位(效果相当于模除mod),得到真值结果
    //   100100000000000000000000       被减数大于减数的二补数运算
    //                                  (浮点数所有减法运算都是,与整数运算不同)
    //result--> (1.00100000000000000000000)2 * (2^0)10
    //          (1.125)10
    //          (1.2)16
    float fa = 1.75 , fb = 0.625;
    printf("fa - fb=(.10f):%.10f,fa - fb=(.10a):%.10a\n", fa - fb, fa - fb);
    printf("fb - fa=(.10f):%.10f,fb - fa=(.10a):%.10a\n", fb - fa, fb - fa);
    return;
}

void float_double_multiplication(void)
{
    // (1.75)10 --> (1.11)2 * (2^0)10
    // (0.625)10 --> (0.101)2 --> (1.01)2 * (2^-1)10
    // (1.11)2 * (2^0)10  *  (1.01)2 * (2^-1)10
    // (1.11  *  1.01)2 * (2^0 * 2^-1)10
    // (1.11  *  1.01)2 * (2^-1)10
    //-------------------------------------------------
    //一般正常算法,但为什么这么算?不直观:
    //           1.11
    //         * 1.01
    //         --------
    //           1 11
    //          00 0    (从乘法竖式本质来说这一步是不存在的和毫无意义的)
    //         111
    //         --------
    //       10.00 11
    // 10.0011 * 2^-1 --> 1.00011 * 2^0
    // 1.1800000000         
    //-------------------------------------------------
    // (1.75)10 --> (1.11)2 * (2^0)10   --> 1.11
    // (0.625)10 --> (0.101)2 * (2^0)10 --> 0.101
    //小数乘法的本质:
    //           (1.110)2    --> 被乘数*8(2^3)倍 1110    
    //         * (0.101)2    -->   乘数*8(2^3)倍  101
    //         ----------
    //
    //           1110
    //         *  101
    //      -----------
    //           1110       *1倍   -->  (1)10倍--->|
    //         1110         *100倍 -->  (4)10倍--->|<--*两倍进一位
    //      -----------                            |
    //        1000110                              |--> 兼具运算速度与本质理解 
    // 1000110/2^6 = 1000110 * 2^-6 = 1.000110 = 1.000110 * 2^0
    //      |--> decimal *ten times(*十倍) 运算时逢十进一
    // 10 --|
    //      |--> binary *two times(*两倍) 运算时逢二进一
    //数学原理: 1 * 1 = 1
    //         1*4 * 1 = 4 (2^2)
    //         1*4 * 1*4 = 16 (2^4)
    //
    //乘法本质的一点理解:
    //      102
    //    *   2
    //   --------
    //        4     拆分成两步,更好理解本质
    //      200
    // 4 + 200 = 204
    //
    float fa = 1.75, fb = 0.625;
    printf("fa * fb(.10a):%.10a, fa * fb(.10f):%.10f\n", fa * fb, fa * fb);
    return;
}

void float_double_division(void)
{
//division
//    2/2 :2根辣条分成两份  --> 2/2=1
//    2/(1/2) :分成1/2根辣条每份,可分成4份 --> 2/(1/2)=2*2=4
// 倒数,指的是两个相乘等于1的数
// 除于一个数等于乘于一个数的倒数   乘法逆元
// (1/2)=2*2=4
// 数学是形式科学不是自然科学。。。啊。。。我要疯了。。。
//小数除法:
//                  -------
//            2.4 _/ 4.92    
//                  -------
//         2.4*10 _/ 4.92*10    
//
//                   2.05
//                 -------
//            24 _/ 49.2    
//                  48
//               ---------
//                   1 20
//                   1 20
//               ---------
//                      0
//
//
//  1.75 --> 1.11000000000000000000000 * (2^0)10
//  0.25 --> 0.01000000000000000000000 * (2^0)10
//  0.25 --> 1.00000000000000000000000 * (2^-2)10
//
//  1.11000000000000000000000 * (2^0)10 / 1.00000000000000000000000 * (2^-2)10
//  (1.11000000000000000000000 / 1.00000000000000000000000) * (2^0)10/(2^-2)10
//  (1.11000000000000000000000 / 1.00000000000000000000000) * [2^0-(-2)]10
//  (1.11000000000000000000000 / 1.00000000000000000000000) * (2^2)10
//   
//                1.11
//               -------
//           1 _/ 1.11
//                1
//               -------
//                  1
//                  1
//               -------
//                   1
//                   1
//               -------
//                   0
//  1.11000000000000000000000 *(2^2)10
//  --> sign(+):   0
//  --> exponent:  2 + 127 = 129 (1000 0001)
//  --> mantissa:  11000000000000000000000
//  --> 0 10000001 11000000000000000000000
//  --> 1.c00000 * (2^2)10
//
    float fa = 1.75, fb = 0.25;
    printf("fa/fb=(.10f):%.10f, fa/fb=(a):%a\n", fa/fb, fa/fb);
    return;
}

void float_double_format_specific(void)
{
    int fa = 1.75, fb = 1.75e1;
    printf("sizeof(int) zd:%zd\n", sizeof(int));
    printf("sizeof(int) d:%d\n", sizeof(int));
    printf("int fa = 1.75: %d\n", fa);
    printf("int fb = 1.75e1: %d\n", fb);
    return;
}


```



## 6. 进制转换 科学计数法
```c
#include <stdio.h>
//===================================================================================
//二进制转十进制 1011 >> 1*2^3 + 1*2^1 + 1*2^0 = 11(10)
//十进制转二进制原理  
// 11(10) = 1*2^3 + 1*2^1 + 1*2^0    =       1*8 + 1*2 + 1*1
//           /2      /2      /2    位值 1    /2    /2    /2 
//          1*2^2 + 1*1^1                    1*4 +  1*1 
//           /2      /2            位值 1    /2    /2 
//          1*2^1                            1*2 
//           /2                    位值 0    /2
//            1                               1
//-----------------------------------------------------------------------------------
// 11(2) 1*2^1 + 1*2^0         10(2) 1*2^1 + 0*2^0
//         /2     /2   位值 1         /2      /2    位值 0
//       1*2^0                       1*2^0    
//         /2          位值 1         /2            位值 1
//-----------------------------------------------------------------------------------
// 101(2) 1*2^2 + 0*2^1 + 1*2^0
//         /2      /2       /2    位值 1
//        1*2^1   0*2^0
//         /2      /2             位值 0
//        1*2^0   
//         /2                     位值 1
//-----------------------------------------------------------------------------------
//个人理解:位权 除 2,除到位权为1,位值*位权=位值*1=位值
//        两种情况: a. 1*1=1; b. 0*1=0 
//        所以：结果为1，则位值为1;结果为0,则位值为0。
//理解关键:前一位的权值比当前位的权值大一个2^1,
//        所以当前位的权值被除到结果为1(2^0)时,前一位的权值被除到结果为2^1
//
//*20200111 整数十进制转二进制更简单的理解:
//  二进制(binary),每一数位的位值为0或1
//  位权大于等于2^1的,它们的位值与位权乘积之和(这里我把这个和叫做sum)肯定能被2整除(division:分裂,除法)
//  位权2^0=1
//  把位权为2^0的数位当做余数:
//      1) 该位数值为0,则 0 * 2^0 = 0 * 1 = 0
//         (sum + 0) /2 = sum/2 + 0/2 = sum/2 + 0 --> sum可以被2整除
//      2) 该位数值为1,则 1 * 2^0 = 1 * 1 = 0
//         (sum + 1) /2 = sum/2 + 1/2 = sum/2 + 1/2 --> 1不能被2整除
//
//      位权大于等于2^1的数位的位值与位权乘积之和,
//         1) 加上余数0,除于2，则余数为0,该位位值为0的情况
//         2) 加上余数1,除于2,则余数为1,该位位值为1的情况
//      
//      除完第一次2以后,我们已得知第一个数位0的位值,不管余数为0或1都丢掉
//      此时数位1的位权变为2^1/2=2^0,以此类推,数位2的位权等于2^2/2=2^1  
//      再重复除于2的步骤,直到求出最高数位的位值为止
//
//===================================================================================
//二进制浮点数小数部分转换十进制:
// .101 = 1*2^-1 + 0*2^-2 + 1*2^-3
//      = 1/2^1  + 0/2^2  + 1/2^3 
//      = 1/2    + 0/4    + 1/8
//      = 0.5    + 0      + 0.125   = 0.625
//十进制浮点数小数部分转换二进制:
// 0.625 * 2 = (1/2 *2) + (1/8 *2)
// 1.25      = 1        +  1/4    
// 0.25      =             1/4       ---->   1
// 0.25  * 2 =             1/4 *2
// 0.5       =             1/2       ---->   0
// 0.5   *2  =             1/2 *2
// 1.0       =             1         ---->   1
// 得到 (.101)2 
// 原理: (.111)2 = 1/2 + 1/4 + 1/8
//       第一次乘2,得到小数点后第一位数值,如果数值是1的话,乘2的结果肯定有整数1,反之,则数值为0
//       第二次乘2,得到小数点后第二位数值,跟上面道理是一样的,后面的依此类推
//       二进制,数值不是0就是1,真舒服...
//       数值为1的话,肯定能余1,为0的话就不会有余数1啦
//
//20200111十进制小数部分转二进制更精准的理解:
//      一定要简单！说话不能太沉醉！--'
//      位权小于等于1/2^2的,乘于2,它们之和还是小于1
//      位权等于1/2^1的,乘于2
//          1) 位值为0,加上上面的之和还是小于1
//          2) 位值为1,加上上面之和后结果大于等于1
//      知道第一位的位值后,丢弃第一位乘2的结果,继续乘于2,
//      相当于重复第一步,因为第二位的位权乘于2后已变成2 * 1/2^2 = 1/2^1
//
//        1/2 + 1/4 + 1/8 + 1/16
//      = 1-1/2 + 1/2-1/4 + 1/4-1/8 + 1/8-1/16
//      = 1 - 1/16
//      = 15/16
//    *这是位值全为1的情况,如果有位值为0, 15/16 - 位值为0的位权,就更小了 
//    *通过这个求解方法可知十进制小数部分转二进制中:
//        位权小于等于1/2^2的,乘于2,它们之和肯定小于1
//
//===================================================================================
//十进制乘法理解:
//        11
//      * 11
//     ------
//        11
//       11
//    -------
//       121
//1. 第二行第一个数  a:1个1,结果放在个位  b:1个10,结果放在十位,是1,十位的权值是10
//2. 第二行第二个数  a:10个1,结果放在十位,是1  b:10个10,结果放在百位,是1
//二进制也是一样的,位置计数法原理都一样,举一反三。。。举一反N
//===================================================================================
//这里说的都是 机器码原码 机器码补码(与数学上的补码/补数有区别) 机器码移码
//原码用 符号位+绝对值 表示
//原码  011         3      补码    011
//      010         2             010
//      001         1             001
//      000         0             000
//      101        -1             111
//      110        -2             110
//      111        -3             101
//                 -4             100   
//字长n=3时,可看出 -4只有补码没有原码,原码没有-0(100),补码中用-0(100)来表示-4
//-----------------------------------------------------------------------------------
//补码由来:  000 001 010 011 | 100 101 110 111   (1段 分隔符 2段)
//          100 101 110 111 | 000 001 010 011   (2段 分隔符 1段)
//          -4  -3  -2  -1     0   1   2   3
//特性 001与111互为补码,mod模为1000
//===================================================================================
//offset binary code 偏移二进制码
//小知识点:w(字长)=3,000的2补数是000
//                                                       offset binary code
//                                           excess_3(bias=(2^w-1)-1=3)    excess_4(bias=2^w-1=4)
//  decimal code | two's complement binary |      (bias binary=011)           (bias binary=100)                      
//        3                 011                         110                       111 
//        2                 010                         101                       110
//        1                 001                         100                       101
//        0                 000                         011                       100
//       -1                 111                       1(010)                    1(011)
//       -2                 110                       1(001)                    1(010)
//       -3                 101                       1(000)                    1(001)
//       -4                 100                         111                     1(000)
//由上表可看出: excess_3与IEEE754标准的excess_127原理是一样的,只是exponent field的字长word不一样
//因此同理可得: 000,111用作 非规格化值 和 特殊值 的移码(课本译作阶码,移码有多个专业名字,具体看英文wiki,太多不想记,脑子不够用...)
//             [001,110]用作 规格化值(standard format) 的移码,观察移码映射到的十进制值,可通过移码(把移码编码当无符号整数编码看)直观地比较大小
//             这就是用移码做指数字段编码的原理
//20200102*: w位二进制数计算,移码减偏置量还等于加偏置量前的补码(二补数)的本质
//           1) 加移码后结果没有溢出,011+011=110, 110-011=110+(1000-011)=110-011+1000(加二补数的本质)
//              结果溢出,计算机只保留w=3位,得到正确结果,又得到011
//           2) 加移码后结果溢出,计算机只保留结果w=3位,例如: 001-011=001+(1000-011)=001-011+1000=1001-011
//
//计算机中浮点数最直观的理解:
//                    sign   exponent    mantissa
//float(单精度浮点型): 0      0000 0000   0000 0000 0000 0000 0000 001   最小非规格化数  
//  二进制表示: value(binary)   = 0.0000 0000 0000 0000 0000 001 * 10^(0000 0001-0111 1111)   excess_127=bias=127(decimal)=0111 1111(binary)
//                             = 0.0000 0000 0000 0000 0000 001 * 10^(-0111 1110)
//  十进制表示: value(decimal)  = 1/2^23 * 2^(-126)
//                             = 2^(-23) * 2^(-126)
//                             = 2^(-149)
//  最小非规格化数(十进制表示) = M * 2^E = 2^-23 * 2^(-126) = 2^(-149) 
//                                                        ≈ 1.4 * 10^(-45)  
//
//                    sign   exponent    mantissa
//float(单精度浮点型): 0      0000 0001   0000 0000 0000 0000 0000 000   最小规格化数  
//  二进制表示: value(binary)   = 1.0000 0000 0000 0000 0000 000 * 10^(0000 0001-0111 1111)   excess_127=bias=127(decimal)=0111 1111(binary)
//                             = 1.0000 0000 0000 0000 0000 000 * 10^(-0111 1110)
//  十进制表示: value(decimal)  = 1*2^0 * 2^(-126) = 2^-126
//                             = 1/2^126
//                             ≈ 1.2 * 10^-38
//
//                    sign   exponent    mantissa
//float(单精度浮点型): 0      1111 1110   1111 1111 1111 1111 1111 111   最大规格化数  
//   二进制表示: value(binary)  = 1.1111 1111 1111 1111 1111 111 * 10^(1111 1110-0111 1111)   excess_127=bias=127(decimal)=0111 1111(binary)
//                             = 1+(1-0.0000 0000 0000 0000 0000 001) * 10^(0111 1111)
//                             = [1+(1- 10^-00010111] * 10^(0111 1111)
//  十进制表示: value(decimal)  = [1+(1- 2^-23)] * 2^127
//                             = (2 - 2^-23) * 2^127
//                             = 2*2^127 - 2^-23 * 2^127
//                             = 2^(1+127) - 2^(-23+127)
//                             = 2^128 - 2^104
//                             = 2^128 - 2^104
//                             = 2^128 - 2^104
//                             ≈ 3.4 * 10^38 = 3.4e38
//
//结论:浮点数有正负0,正负float取值范围是对称的,float的取值范围[-3.4e38,3.4e38],double/long double同理
//-----------------------------------------------------------------------------------
// 6.75(10) >> 110.11(2)
// 科学计数法  十进制 123.456*10^2(10) 1.23456*10^4(10) 0.123456*10^5(10)
//            二进制 A: 1.1011*2^2(2)   整数部分最高位1放小数点前
//                  B: 0.11011*2^3(2)  整数部分最高位1放小数点后   
//计算机中以A方式存储浮点数的尾数,默认隐含1.
//在内存中尾数以1011存储,整数部分最高位肯定为1,隐藏1.，原因如下:
//不以B方式储存是为了节省存储空间吧...到底是不是要去问创造C语言的大佬(￣ェ￣;)
//计算机中浮点数的存储方式(以float 6.75 为例,float数据类型存储长度为4个字节byte 32位bit):
//以下内容在《计算机科学导论》P36 更详细
//附加知识点:尾数以符号加绝对值表示法储存(sign+mantissa) 《计算机科学导论》P30
// 符号            指数                     定点数    科学计数法
// 符号            指数                     尾数      规范化
//           阶符1bit 阶码7bit
// 1bit            8bit                   23bit
//  0           0   10              (隐含1.)1011    注:非真实存储数据,只是描述存储了哪部分(小数点左边保留一位数码)
// 0|1             余码             (隐含1.)10110000000000000000000 尾数右边填充0直到填满23位存储单元
//比较两个浮点数大小的先后顺序,出现数值相等的情况才会继续下一步,不相等则直接得到比较大小的结果:
// 先比较 (个人假想,待验证)符号位sign   (+ > -) (0 > 1)   这个是我自己想的... 等后面看到教程或书籍有提到才能证实--'
//        指数exponent    规范化后 指数越大当然浮点数越大
//        尾数mantissa   用比较整数的方法比较大小  从高位向低位比较   01110 > 01101
//===================================================================================
//fractional 分数的,小数的
//fraction 分数,小数
//standard 标准
//移码(偏码.增码.译码,余码)
//offset binary:偏移二进制码
//excess:超过,超过的量 1)excess_127:偏移量127(IEEE754偏移量) 2)excess_128(标准偏移量)
//IEEE754标准 移码(计算机中存储的移码)
//-----------------------------------------------------------------------------------
//《深入理解计算机系统》(第三版) P80 图2-35 理解计算机浮点数格式的秘籍啊......
//指数exponent的值分三种情况,以float数据类型为例:
//  A. 规格化的值: 
//     exponent field为[0000 0001,0111 1111] --> [1,254]
//     E= e-127(bias偏置值) = [1,254]-127  ---> [-126,127]
//                          = [0000 0001,0111 1111] - [0111 1111]  
//     M(尾数的值) = 1+f(描述小数值 .f-1 f-2 ...)
//     mantissa尾数 隐含1. ,所以规格化的值无法表示0         
//
//  B. 非规格化的值: 
//     阶码字段全是0,exponent field指数字段(书本译作阶码)为[0000 0000]
//     E= 1-127(bias偏置值) = -126
//     M(尾数的值) = f(描述小数值)
//     mantissa尾数 隐含0.(书本不隐含1.)
//     sign为0,exponent全为0: 1) mantissa全为0     表示 +0
//                            2) mantissa: M = f  表示 +0.bbb...
//     sing为1,exponent全为0: 1) mantissa全为0     表示 -0
//                            2) mantissa: M = f  表示 -0.bbb...
//
//  C  特殊值:
//     a) exponent field[1111 1111],小数域全为0[0000 0000 0000 0000 000]
//        sign为0,+∞ 正无穷
//        sign为1,-∞ 负无穷
//        
//     b) exponent field[1111 1111],小数域为非0,结果值被称为"NaN"(Not a Number)
//看完上面这段文字如果你一脸懵逼,你是不是怀疑人生,觉得自己很蠢,你就是个傻子,哈哈哈哈~
//没事~接下来直接看下面这个正浮点数的表~哈哈哈哈哈哈哈哈 
//
//正浮点数: 1) 这里的f表示小数部分,小数=整数部分.小数部分
//         2) 下表中 假设指数字段3bit,尾数字段2bit,符号位不说也知道是1bit吧
//                     sign  exponent  mantissa    word
//             float   1bit   8bit      23bit   4byte 32bit
//             double  1bit  11bit      52bit   8byte 64bit
//         3) b(bias偏置量)=2^(3-1)-1=3
//         4) e:假定阶码(指数)字段是一个无符号整数所表示的值
//            E:偏置之后的阶码(指数)值
//
//  --------------------bias(binary)------------------------bias(decimal)-------------------------------------------------------------------
//             float   1000 0000 - 0000 0001=0111 1111     1*2^7 - 1 = 127  
//             double  同上,位数填满到11位                   1*2^10 - 1 = 1023
//     -------位表示bit representation--------             
//     sign[S]   exponent[E]    mantissa[M]       [S]  [E]decimal--fraction  [M]mantissa  ---------------[value]--------------
//   非规格数---------------------------------           e  E=(1-b)   2^E     binary      binary *decimal      decimal fraction
//       0           000         00   (0+f)        +    0   -2       1/4      0.00       (0.00)2 * 2^-2   (0*1 + 0*1/2 + 0*1/4) * 1/4 = 0/16
//       0           000         01   (0+f)        +    0   -2       1/4      0.00       (0.01)2 * 2^-2   (0*1 + 0*1/2 + 1*1/4) * 1/4 = 1/16 
//       0           000         10   (0+f)        +    0   -2       1/4      0.00       (0.10)2 * 2^-2   (0*1 + 1*1/2 + 0*1/4) * 1/4 = 2/16
//       0           000         11   (0+f)        +    0   -2       1/4      0.00       (0.11)2 * 2^-2   (0*1 + 1*1/2 + 1*1/4) * 1/4 = 3/16 
//   规格数-----------------------------------
//       0           001         00   (1+f)        +    1   -2       1/4      1.00       (1.00)2 * 2^-2   (1*1 + 0*1/2 + 0*1/4) * 1/4 = 4/16
//       0           001         01   (1+f)        +    1   -2       1/4      1.01       (1.01)2 * 2^-2   (1*1 + 0*1/2 + 1*1/4) * 1/4 = 5/16
//       0           001         10   (1+f)        +    1   -2       1/4      1.10       (1.10)2 * 2^-2   (1*1 + 1*1/2 + 0*1/4) * 1/4 = 6/16
//       0           001         11   (1+f)        +    1   -2       1/4      1.11       (1.11)2 * 2^-2   (1*1 + 1*1/2 + 1*1/4) * 1/4 = 7/16
//
//       0           010         00   (1+f)        +    2   -1       1/2      1.00       (1.00)2 * 2^-1   (1*1 + 0*1/2 + 0*1/4) * 1/2 = 8/16
//       0           010         01   (1+f)        +    2   -1       1/2      1.01       (1.01)2 * 2^-1   (1*1 + 0*1/2 + 1*1/4) * 1/2 = 10/16
//       0           010         10   (1+f)        +    2   -1       1/2      1.10       (1.10)2 * 2^-1   (1*1 + 1*1/2 + 0*1/4) * 1/2 = 12/16
//       0           010         11   (1+f)        +    2   -1       1/2      1.11       (1.11)2 * 2^-1   (1*1 + 1*1/2 + 1*1/4) * 1/2 = 14/16
//
//       0           011         00   (1+f)        +    3    0        1       1.00       (1.00)2 * 2^0    (1*1 + 0*1/2 + 0*1/4) *  1  = 16/16
//       0           011         01   (1+f)        +    3    0        1       1.01       (1.01)2 * 2^0    (1*1 + 0*1/2 + 1*1/4) *  1  = 20/16 
//       0           011         10   (1+f)        +    3    0        1       1.10       (1.10)2 * 2^0    (1*1 + 1*1/2 + 0*1/4) *  1  = 24/16
//       0           011         11   (1+f)        +    3    0        1       1.11       (1.11)2 * 2^0    (1*1 + 1*1/2 + 1*1/4) *  1  = 28/16 
//
//       0           100         00   (1+f)        +    4    1        2       1.00       (1.00)2 * 2^1    (1*1 + 0*1/2 + 0*1/4) *  2  = 32/16
//       0           100         01   (1+f)        +    4    1        2       1.01       (1.01)2 * 2^1    (1*1 + 0*1/2 + 1*1/4) *  2  = 40/16
//       0           100         10   (1+f)        +    4    1        2       1.10       (1.10)2 * 2^1    (1*1 + 1*1/2 + 0*1/4) *  2  = 48/16
//       0           100         11   (1+f)        +    4    1        2       1.11       (1.11)2 * 2^1    (1*1 + 1*1/2 + 1*1/4) *  2  = 56/16
//
//       0           101         00   (1+f)        +    5    2        4       1.00       (1.00)2 * 2^2    (1*1 + 0*1/2 + 0*1/4) *  4  = 64/16
//       0           101         01   (1+f)        +    5    2        4       1.01       (1.01)2 * 2^2    (1*1 + 0*1/2 + 1*1/4) *  4  = 80/16
//       0           101         10   (1+f)        +    5    2        4       1.10       (1.10)2 * 2^2    (1*1 + 1*1/2 + 0*1/4) *  4  = 96/16
//       0           101         11   (1+f)        +    5    2        4       1.11       (1.11)2 * 2^2    (1*1 + 1*1/2 + 1*1/4) *  4  = 112/16
//
//       0           110         00   (1+f)        +    6    3        8       1.00       (1.00)2 * 2^3    (1*1 + 0*1/2 + 0*1/4) *  8  = 128/16
//       0           110         01   (1+f)        +    6    3        8       1.01       (1.01)2 * 2^3    (1*1 + 0*1/2 + 1*1/4) *  8  = 160/16
//       0           110         10   (1+f)        +    6    3        8       1.10       (1.10)2 * 2^3    (1*1 + 1*1/2 + 0*1/4) *  8  = 192/16
//       0           110         11   (1+f)        +    6    3        8       1.11       (1.11)2 * 2^3    (1*1 + 1*1/2 + 1*1/4) *  8  = 224/16
//   特殊值-----------------------------------
//       0           111         00   (1+f)        +∞ 正无穷       
//       0           111         ...  (1+f)        NaN(Not a Number)    
//   ----------------------------------------
//负浮点数道理同上[-0,-∞]
//===================================================================================
int main(void)
{
    //power 幂 科学计数法 1*10^8、2.234*10^6
    //exponent 指数计数法中的指数 指数计数法 1.334e10、2.14e-3
    //实数的两种格式,在C语言中可以像下面=后面那样这样省略:
    //decimal notation 11.11, 0.11=.11, 11.0=11 
    //exponential notation 1.23e2, 0.23e4=.23e4, 23.0e4=23e4, 19.11e-1=19.11 
    float f1 = 1e6, f2 = .001234, f3 = 123, f4 = 666.666, f_var, f_infinity, f_min;
    double d1, d2 = 666.666, d_max=1.79e308;
    long double ld1, ld2 = 6.6666666;
    //format specifier:格式说明符(c primer plus中文版翻转换说明,我觉得格式说明符更好)
    //format specifier example: %d %f...
    //decimal notation 十进制计数法 notation 记号,符号
    //exponential notation 指数计数法,e指数计数,
    printf("These is decimal notation float: %f, %f, %f, %f,.\n", f1, f2, f3, f4);
    printf("These is decimal notation double: %f, %f.\n", d1, d2);
    printf("These is exponential notation float: %e, %e, %e, %e.\n", f1, f2, f3, f4);
    printf("These is exponetial notation double: %e, %e.\n\n", d1, d2);
    //*注意:windows下用gcc编译(8.1.0),long double存在问题(网上说的,我linux系统删了,没法验证,但现在在windows7下确实输出结果有问题)
    //*long double 后续补充: 《深入理解计算机系统》P119 3.3 第二段 历史上特殊的浮点数格式,不建议用,不能移植...好吧,反正我也没有要用...
    printf("These is decimal notation long double: %Lf, %Lf.\n", ld1, ld2);
    printf("These is exponetial notation long double: %Le, %Le.\n\n", ld1, ld2);
    //float有效为最少6位,double有效位至少10位,long double有效位至少13位,有效位就是小数点后保留的位数
    //char constant(字符常量)与int constant(整数常量一样),占4个字节
    //*编译器默认假定浮点数常量为double型,8个字节，64位,想要float或long double constant的在后面加suffix后缀
    //浮点数常量后面加f或F,编译器会把这个浮点数常量看作float类型
    //浮点数常量后面加l(L小写)或L,则编译器会看作long double类型,建议加L,小写L跟1(阿拉伯数字一)太像了。。。
    //suffix:后缀
    printf("Size of float/double/long double constant(no suffix): %d,%d,%d.\n", \
        sizeof(111.111111), sizeof(111.1111111111e-2), sizeof(111.1111111111111));
    printf("Size of float constant(have suffix f or F): %d.\n", sizeof(111.11F));
    printf("Size of long double constant(have suffix L): %d.\n", sizeof(111.11L));
    printf("Size of float variable: %d.\n", sizeof(f1));
    printf("Size of dobule variable: %d.\n", sizeof(d1));
    printf("Size of long dobule variable: %d.\n", sizeof(ld1));
    printf("sizeof(f1*2.0f): %d, sizeof(2.0f*2.0f): %d, sizeof(2.0f*2.0): %d\n", \
        sizeof(f1*2.0f), sizeof(2.0f*2.0f), sizeof(2.0f*2.0));
    printf("sizeof(2e10+1.0):%d, sizeof(f_var=2e10+1.0):%d\n", sizeof(2e10+1.0), sizeof(f_var=2e10+1.0));
    //printf("This is double:%.10f\n", d2);
    //printf("This is long double:%.20Lf\n", ld2);
    //*知识点:C99标准添加的十六进制浮点数常量格式: 
    // 1.ap10  mantisa:(1.a)16; 重点->p10=2^10  
    printf("float (hexadecimal,(mantissa)16*(2^E)10): %a\n", f_var=5.5F); //%a format specifier,以16进制hexadecimal指数形式输出浮点数
    printf("float (hexadecimal,(mantissa)16*(2^E)10): %a\n", f_var=1.2e-38F);
    printf("float Max(hexadecimal,(mantissa)16*(2^E)10): %a\n", f_var=3.4e38);
    printf("float Min(hexadecimal,(mantissa)16*(2^E)10): %a\n", f_var=-3.4e38);
    printf("float Max(hexadecimal,(mantissa)16*(2^E)10): %a\n", f_var=3.4e38);
    printf("float Min(hexadecimal,(mantissa)16*(2^E)10): %a\n", f_var=-3.4e38);
    printf("float Max(decimal): %f\n", f_var=3.4e38);
    printf("float Min(decimal): %f\n", f_var=-3.4e38);
    printf("double Max(decimal): %f\n", d_max);
    printf("double Max(exponential notation): %e\n", d_max);
    printf("double Max(hexadecimal,(mantissa)16*(2^E)10): %a\n", d_max);
    //infinity 无穷,无限
    printf("float +infinity(hexadecimal,(mantissa)16*(2^E)10): %a\n", f_infinity=3.4e39);
    printf("float +infinity(hexadecimal,(mantissa)16*(2^E)10): %a\n", f_infinity=3.5e38);
    printf("float -infinity(hexadecimal,(mantissa)16*(2^E)10): %a\n", f_infinity=-3.4e39);
    printf("float -infinity(hexadecimal,(mantissa)16*(2^E)10): %a\n", f_infinity=-3.5e38);
    return 0;
}



```

## 7.assic编码  
```c
  
// ANSI(american national standards institute):美国国家标准学会
// 'x' 一个字符   | x |    |
// "x" 一个字符串 | x | \0 |
// \0 空字符:null character(非打印字符)
//scanf()函数会自动添加空字符
//scnaf() 只会读取fyfa fyfb中的fyfa
//--------------------------------------------------------------
//conversion specification(转换说明) 例如: %d %f
// 1) printf() --> conversion specification表 《c primer plus第六版》P195
//--------------------------------------------------------------
//字符串常量 编译器会添加空字符
#include <stdio.h>
#include <string.h>      /* 该头文件提供strlen()函数 */
//编译程序的时候,程序中的符号常量会被替换成所定义的值(常量),编译时替换(compile-time substitution)
//符号常量后面的内容被用来替换符号常量 《c primer plus第六版》p189
#define C 'A'
#define NAME "Fu YunFeng." /* 定义符号常量 */
#define PI 3.141593         /* 定义符号常量(symbolic constant) */
void code_new_line(void);
void circle_float_arithmetic(void);
void circle_double_arithmetic(void);
void circle_long_double_arithmetic(void);
void define_and_const(void);
void stdio_include_stddef_size_type(void);
void conversion_specification_modifiers_and_flags(void);
void printf_function_stack_a(void);
void printf_function_stack_b(void);
void print_long_string_methods(void);

void main(void)
{
    //c_var[40]是一个可容纳40个字符的数组
    //该字符数组占用内存中连续 1*40个字节byte
    //定义字符类型数组
    char c_var[40];
    //该短整型数组占用内存中连续 2*5个字节byte
    short int si_var[5];
    printf("character string 字符串,string constant Name: %s\n", NAME);
    // \b 光标向左移一位,一个字符占一位 
    printf("Input You Name:__________\b\b\b\b\b\b\b\b\b\b");
    scanf("%s", c_var);
    printf("My Name is:%s\n", c_var);
    //strlen()函数获取字符串的长度,获取空字符(null character)之前的字符串的长度
    // strlen()函数 和 sizeof运算符 返回值为无符号整数类型(unsigned integer)  注:网上说的...不知道对不对
    // 输出返回值用%zd或%u,C99和C11标准用%zd,较早的C用%u
    // sizeof运算符用法示例: 1)sizeof(object);  2)sizeof object;  3)sizeof(type);
    printf("string length, strlen(c_var): %u\n", strlen(c_var));
    printf("string length, strlen(NAME): %u\n", strlen(NAME));
    printf("sizeof(c_var): %u\n", sizeof(c_var));
    //计算机主存每字节都有一个唯一的物理地址(physical address),物理寻址physical addressing
    //&取数组变量的地址(虚拟地址virtual address\虚拟寻址virtual addressing)
    //CPU芯片上的内存管理单元(memory management unit: MMU)将虚拟地址转换成物理地址
    //《深入理解计算机系统第三版》 P560 
    printf("sizeof(&c_var): %u\n", sizeof(&c_var));
    //&c_var是数组第一个字节的虚拟地址(个人理解,待验证)
    printf("lx(&c_var)/64bit virtual address(hexadecimal): %lx\n", &c_var);
    printf("sizeof(si_var): %u\n", sizeof(si_var));
    printf("sizeof(&si_var): %u\n", sizeof(&si_var));

    code_new_line();
    circle_float_arithmetic();
    circle_double_arithmetic();
    circle_long_double_arithmetic();
    define_and_const();
    stdio_include_stddef_size_type();
    conversion_specification_modifiers_and_flags();
    printf_function_stack_a();
    printf_function_stack_b();
    print_long_string_methods();
    return;
}

void code_new_line(void)
{
    printf("233333333333333333333333333333333333333333, This is my name: %s\n", NAME);
    //处理很长的printf()语句的两种方法:
    // 1)
    printf("233333333333333333333333333333333333333333, This is my name: %s\n",
     NAME);
    // 2)
    printf("233333333333333333333333333333333333333333, ");
    printf("This is my name: %s\n", NAME);
    return;
}

//格式说明符(format specific) 
//注:long double类型有点特殊,需要考虑硬件,操作系统等因素,虽然编译器有定义这个类型,我暂时用不到就不折腾了...
// [1] scanf()
//     float: %f %e %a
//     double: %lf %le %la
//     long double: %Lf %Le %La
// [2] printf()
//     %f %e 默认保留小数点后六位
//     float: %f %e %a
//     double: %f %e %a
//     long double: %f %e %a  
// 浮点数不加后缀,默认double类型
void circle_float_arithmetic(void)
{
    float r, l, a;
    printf("sizeof(r): %zd, sizeof(PI): %zd\n",
     sizeof(r), sizeof(PI));
    printf("input r(floating-point number):______\b\b\b\b\b\b");
    scanf("%f", &r);
    l = 2.0 * PI * r;
    a = PI * r * r;
    printf("circle_l(f): %f, circle_a(f): %f\n", l, a);
    printf("circle_l(e): %e, circle_a(e): %e\n", l, a);
    printf("circle_l(a): %a, circle_a(a): %a\n", l, a);
    return;
}

void circle_double_arithmetic(void)
{
    double d_r, d_l, d_a;
    printf("sizeof(d_r): %zd,sizeof(PI): %zd\n",
     sizeof(d_r), sizeof(PI));
    printf("input d_r(floating-point number):______\b\b\b\b\b\b");
    scanf("%lf", &d_r);
    d_l = 2.0 * PI * d_r;
    d_a = PI * d_r * d_r;
    printf("circle_l(f): %f, circle_a(f): %f\n", d_l, d_a);
    printf("circle_l(e): %e, circle_a(e): %e\n", d_l, d_a);
    printf("circle_l(a): %a, circle_a(a): %a\n", d_l, d_a);
    return;
}

void circle_long_double_arithmetic(void)
{
    float f_a = 1.3F;
    double d_a = 1.3;
    printf("sizeof(f_a): %zd\n", sizeof(f_a));
    printf("%.60f\n", f_a);
    printf("%.60e\n", f_a);
    printf("%.60a\n", f_a);
    printf("sizeof(d_a): %zd\n", sizeof(d_a));
    printf("%.60f\n", d_a);
    printf("%.60e\n", d_a);
    printf("%.60a\n", d_a);
    return;
}

void define_and_const(void)
{
    //const关键字(key woird)限定一个变量为只读,赋值编译器会报错
    // short long signed unsigned const 限定符
    //用法比define更灵活
    // PI = 5.555; 符号常量不能更改其内容
    // csi_b = 88; const限定变量只读,不可更改
    const short int csi_a = 55, csi_b = 66;
    printf("csi_a(%%hd)%hd\n", csi_a);
    printf("csi_b(%%hd)%hd\n", csi_b);
    // 计算机中储存的是 3.14159的近似值
    // %%   printf()转换说明 打印一个百分号
    printf("PI(%%f): %f\n", PI);
    printf("PI(%%.10f): %.10e\n", PI);
    // double类型 尾数52位,因此只能计算最长值 %.13a,超过这个长度后面只是填充0而已
    printf("PI(%%.13a): %.13a\n", PI);
    printf("PI(%%.15a): %.15a\n", PI);
    return;
}
// printf("格式化字符串/转换说明", 待打印列表)
// 待打印列表项: 常量,变量,表达式的值
// 《c primer plus第六版》P200 表4.5 转换说明修饰符
// 需要注意的: l和整数转换说明使用,L和浮点数转换说明使用

void stdio_include_stddef_size_type(void)
{
    int i_a = 111;
    float f_a = 1.0, f_b = 2.0, f_var_a = 1.0, f_var_b;
    double d_var_a = 1.0;
    size_t size_type_a;
    // long unsigned int
    //       |
    //       V
    // __SIZE_TYPE__  
    //       |------------> 定义size_t类型(underlying type:底层类型) 
    //                      具体怎么定义的要看头文件源码,目前水平有限,暂时理解到这了...
    // 
    // stddef.h(在包含stdio.h时已包含其中,书本上说的,具体怎么实现我目前还不懂。。。)头文件中, 
    // C标准只规定了sizeof返回值类型为无符号整数类型
    // #define __SIZE_TYPE__ long unsigned int 
    // (可移植性更好 sizeof返回值类型,不同编译器,
    // unsigned int, unsigned long, unsigned long long都有可能)
    // z修饰符和整数转换说明一起使用,表示size_t类型的值
    // printf() conversion specification modifiers 输出函数转换说明修饰符
    printf("sizeof(int): %zd\n", sizeof(int));
    printf("sizeof(size_t): %zd --> long unsigned int\n", sizeof(size_t));
    printf("sizeof(sizeof(int)): %zd --> long unsigned int\n",
     sizeof(sizeof(int)));
    printf("sizeof(float): %zd\n", sizeof(float));
    printf("sizeof(double): %zd\n", sizeof(double));
    printf("sizeof(1.0): %zd\n", sizeof(1.0));
    printf("sizeof(f_a): %zd\n", sizeof(f_a));
    printf("constant 99.99 (x): %x\n", 99.99);
    printf("sizeof(f_b): %zd\n", sizeof(f_b));
    //printf() 的浮点数转换说明为什么只有 %f
    //历史遗留问题,为了兼容
    //因为在K&R C中,表达式或参数中的float类型会被自动转换成double类型
    //具体看《c primer plus第六版》P201
    // f_a*f_b表达式返回值打印结果可看出,一般而言,ANSI C不会自动把float转换成double
    //《c primer plus第六版》P201 第8行
    //从f_var_a和d_var_a两个变量的打印结果可印证,printf()的float仍自动转换成double
    //所以没有float类型的专用转换说明,float和double类型都是用%f
    printf("sizeof(f_a*f_b): %zd\n", sizeof(f_a*f_b));
    printf("sizeof(f_a*2.0): %zd\n", sizeof(f_a*2.0));
    printf("sizeof(f_a*d_var_a): %zd\n", sizeof(f_a*d_var_a));
    printf("f_var_a=1.0 (a): %a\n", f_var_a);
    printf("d_var_a=1.0 (a): %a\n", d_var_a);
    printf("f_var_a=1.0 (x): %x\n", f_var_a);
    printf("f_var_a=1.0 (lx): %lx\n", f_var_a);
    printf("d_var_a=1.0 (x): %x\n", d_var_a);
    printf("d_var_a=1.0 (lx): %lx\n", d_var_a);
    //《c primer plus第六版》P201 表4.5 printf()中的标记(flags)
    // +标记  值为正,则前面显示+号;值为负,则前面显示-号
    printf("f_a(%%+.2f): %+.2f\n", f_a);
    // (一个空格)标记  值为正,则前面显示一个空格;值为负,则前面显示-号
    printf("f_a(%% .2f): % .2f\n", f_a);
    // %10d 整数字段宽度10(个人感觉10个字符宽度更容易理解)
    printf("i_a(%%10d): *%10d*\n", i_a);
    // %010d 整数字段宽度为10,数值位数不足的前面填充0
    printf("i_a(%%010d): *%010d*\n", i_a);
    // %-10d 整数字段宽度10, -标记 左对齐
    printf("i_a(%%-10d): *%-10d*\n", i_a);
    // 浮点数类型的修饰符和标记也是相同原理
    // %10.2f 表示字段宽度10,保留小数点后两位,其它的就全部展示了
    // 要了解看《c primer plus第六版》P203就好了
    printf("11.3(%%e): *%e*\n", 11.3);
    printf("11.3(%%.2e): *%.2e*\n", 11.3);
    // rounding 舍入
    printf("11.3(%%.1e): *%.1e*\n", 11.3);
    printf("11.4(%%.1e): *%.1e*\n", 11.4);
    printf("11.5(%%.1e): *%.1e*\n", 11.5);
    printf("11.3(%%10.2e): *%10.2e*\n", 11.3);
    printf("1.3(%%10.2e): *%10.2e*\n", 1.3);
    // 下面的两种情况会对结果进行舍入rounding
    printf("1.399(%%10.2e): *%10.2e*\n", 1.399);
    printf("1.399(%%10.1e): *%10.1e*\n", 1.399);
    return;
}

void conversion_specification_modifiers_and_flags(void)
{
    const double cd_a = 123456.789;
    float f_a = 3.0;
    double d_a = 3.4e39;
    printf("cd_a(%%.3f): %.3f\n", cd_a);
    // %E e输出变大写字母E
    printf("cd_a(%%E): %E\n", cd_a);
    // flags # 显示前缀
    printf("cd_a(%%#lx): %#lx\n", cd_a);
    // %X 十六进制中的字母输出大写字母格式
    printf("cd_a(%%#lX): %#lX\n", cd_a);
    // .3d 整数数值位数不够的前面填充0 
    // 5d  整数数值位数不够的前面填充空格
    // 相同点,整数数值位数足够或超过的,以原值为准输出
    // 10d 字段宽度10
    printf("6(*%%10.3d*): *%10.3d*\n", 6);
    // character string 字符串 flags 标记
    printf("NAME([%%s]): [%s]\n", NAME);
    // %.5s 只输出字符串前面5个字符
    printf("NAME([%%.5s]): [%.5s]\n", NAME);
    // %30s 输出字符串宽度30,字符数不足的前面填充空格
    printf("NAME([%%30s]): [%30s]\n", NAME);
    printf("f_a(%%ld): %ld\n", f_a);
    printf("d_a(%%ld): %ld\n", d_a);
    return;
}

//标记: printf() --> - 左对齐; + 正数加正号,负数加负号;  空格; 0 填充0; # 前缀
//  注: %.5d(输出整数位数最少为5,不足补0)
//      %.5f(保留小数点后5位)
//      %.5s(输出字符串前5个字符)
//      %5d %5f %5s (输出字段宽度为5)
//
// 转换说明的意义:
//    转换说明实际上是翻译说明,
//    把计算机中储存的二进制数"转换"(翻译)成文本(字符/字符串)打印出来
//    并不改变计算机中储存的数据(原始值)
//
//温故知新: binary division 二进制除法
//           _____        
//     1000_/ 1101 
// 1) 最高位1不能分成1000份
// 2) 先把1拆成10份,10就是10份个1,加上后一位的1份,就是10+1=11
// 3) 后面同理,懒得写了...
// 这里我不转换成十进制来读,十进制来理解原理就好
// 

void printf_function_stack_a(void)
{
    unsigned short int usi_a = 16352U, usi_b = 49120U;
    // 16352U                     0011 1111 1110 0000
    // 16352  0000 0000 0000 0000 0011 1111 1110 0000
    // 49120U                     1011 1111 1110 0000
    // 49120  0000 0000 0000 0000 1011 1111 1110 0000
    unsigned int ui_a = 3220176896, ui_b = 3220176896U;
    unsigned long int uli_a;
    double d_a = 1.0;
    printf("ui_a(%%u): %u\n", ui_a);
    //有符号整数常量4byte, 32bit编码储存不了有符号数3220176896,编译器转换成64bit储存
    printf("int constant 3220176896(%%x): %x, sizeof(3220176896): %zd\n",
     3220176896, sizeof(3220176896));
    printf("int constant 3220176896U(%%x): %x, sizeof(3220176896U): %zd\n",
     3220176896U, sizeof(3220176896U));
    //为正数时前面的0输出是被省略了,输出负数时就可以看出前面是有填充1的
    printf("int constant 3220176896(%%lx): %lx\n", 3220176896);
    printf("int constant -3220176896(%%lx): %lx\n", -3220176896);
    printf("int constant -3220176896(%%x): %x\n", -3220176896);
    printf("3220176896U(%%lx): %lx\n", 3220176896U);
    printf("usi_a(%%hu): %hu\n", usi_a);
    printf("usi_a(%%a): %a\n", usi_a);
    printf("usi_a(%%e): %e\n", usi_a);
    printf("usi_a(%%x): %x\n", usi_a);
    printf("usi_a(%%lx): %lx\n", usi_a);
    printf("d_a(%%lx): %lx\n", d_a);
    printf("1) 16.125(%%f):  %f\n", 16.125);
    printf("2) 16.125(%%lx): %lx\n", 16.125);
    printf("3) 16.125(%%a):  %a\n", 16.125);
    printf("4) 16.125(%%e):  %e\n", 16.125);
    /*
    exponent
   true value  binary    two's complement      excess_3
        3     [ 011]--|     |-- 011 --|      |--  110 --|            |-- 1 011
        2     [ 010]  |     |   010   |      |    101   |            |   1 010
        1     [ 001]  |     |   001   |      |    100   |            |   1 001
        0     [ 000]  | map |   000   | +011 |    011   | -011(+101) |   1 000
       -1     [-001]  |     |   111   |      |  1 010   |            |     111
       -2     [-010]  |     |   110   |      |  1 001   |            |     110
       -3     [-011]  |     |   101   |      |  1 000   |            |     101
       -4     [-100]--|     |-- 100 --|      |--  111 --|            |-- 1 100
    binary --> two's complement -- +011 --> excess_3 
    binary 000(包括000)以上+011为正数加正数
           这运算结果区间都为正数(这区间的结果并不是结果的二补数编码,因为编码位数不够,最高位符号位为1,会有溢出)
    binary -001(包括-001)以下+011为负数加正数,这里负数转换为二补数进行加法运算
           运算结果为正,则modulo模除1000得到正确结果;运算结果为负,则得到结果的绝对值的二补数
    excess_3 000(包括000)以上非负数,111唯一负数的二补数,
             -011转换成+101二补数运算
             结果000(包括000)以上,结果为正,模除1000得到正确结果
             [101,111]负数结果区间,得到正确结果绝对值的二补数
             1 100由于两个负数相减,转换成二补数运算,相当于加了两次1000,所以模除1000后得到正确结果绝对值的二补数
    阶码:二补数运算。 有符号整数:二补数编码运算
    */
    return;
}

void printf_function_stack_b(void)
{
    //参数传递 stack栈 《c primer plus第六版》P212
    //程序把传入的值放入被称为栈的内存区域
    //计算机根据变量类型把这些值放入栈中
    //参数传递机制因编译器实现而异
    //书本中可能编译器的版本问题
    //目前我用的编译器并未出现里面所介绍的输出错误
    float n1 = 3.0;
    double n2 = 3.0;
    short int si_return_value;
    int i_return_value;
    long int n3 = 2000000000;
    long int n4 = 1234567890;
    printf("n1(%%ld): %ld,n2(%%ld): %ld,n3(%%ld): %ld,n4(%%ld): %ld\n",
     n1, n2, n3, n4);
    printf("n1(%%d): %d,n2(%%d): %d,n3(%%d): %d,n4(%%d): %d\n",
     n1, n2, n3, n4);
    // 大部分C函数都有一个返回值
    // 可赋值给变量,可作为参数传递,可参与运算
    // *总之,就是可以把返回值当作其它数值一样使用
    //下面两句代码,输出且把返回值赋值给变量
    si_return_value = printf("12345 67890: %f\n", n2);
    i_return_value = printf("12345 67890: %f\n", n2);
    // 标准C库函数printf()返回值为打印字符的个数
    // 由运行输出结果可得到printf()函数返回值,
    // 有结果可知计算字符个数结果包括:空格,转义序列(转义字符)
    printf("return value of printf function (%%hd): %hd\n", si_return_value);
    printf("return value of printf function (%%hd): %d\n", i_return_value);
    printf("sizeof(si_return_value): %zd\n", sizeof(si_return_value));
    printf("sizeof(si_return_value): %zd\n", sizeof(i_return_value));
    // printf()返回值是一个整数类型,size: 4byte
    // 是int还是unsigned int还要验证...
    printf("sizeof(printf function return value): %zd\n",
     sizeof(printf("12345 67890,%f\n", n2)));
    return;
}

void print_long_string_methods(void)
{
    // 打印较长字符串的三种方法:
    // [1]
    printf("abcd");
    printf("efg\n");
    
    // [2]
    // ANSI c引入的字符串连接
    // 两个双引号括起来的字符串之间用空格隔开
    // C编译器会把这两个字符串看作是一个字符串
    // 多个字符串也一样
    // 比较容易记的说法: C编译器把多个用空格隔开的字符串看作一个字符串
    printf("a"     "b"            "c\n"); /*本质*/
    printf("abcd"
    "efg\n");
    printf("123"
    "456"
    "789\n");

    // [3] 注:字符串的第二行代码必须从最左边开始,
    //        不然前面的空格会成为字符串一部分,输出的字符串就会包含空格
    /* 
        printf函数中的字符串常量不能含有enter回车键产生的换行符
        包含的话编译器会报错
        示例:
            printf("abcd
            efg\n"); 
    */
    // 反斜杠\ 加 enter(回车)的组合 -->  \换行符
    printf("a\
bcd\n");
    //通过输出结果可知字符串代码第二行前面的空格是两个非显示字符
    //*字符串在内存的存储并非我想的那么简单,目前水平有限,先跳过。。。--'
    printf("%zd\n", printf("a\
    bc\n"));
    printf("%lx\n", "a\
    bc\n");
    
    printf("%zd\n", printf("a\
    b\n"));
    printf("%lx\n", "a\
    b\n");
    return;
}



```



## 8. 字符输入输出 打印 格式化
```c
  
#include<stdio.h>
//  《c primer plus第六版》P217 第三段重点
//  *键盘只能生成文本字符: 字母,数字,标点符号
//  要输入整数1024
//  键盘键入字符 1 0 2 4
//  scanf函数 把 字符串 转化成 整数1024
//  character 字符; character string 字符串.
//
//printf()和scanf()函数参数：
//  [1] printf()函数使用变量,常量,可求值的表达式,有返回值的函数
//  [2] scanf()函数使用指向变量的指针
//
//scanf()读取基本类型变量的值,在变量名前加&
//scanf()读取字符串,储存到字符数组中,不使用&
void scanf_format_character_string(void);
void scanf_conversion_specification_character(void);
//void scanf_return_value(void);
void printf_star_modifier(void);
void scanf_star_modifier(void);
void usage_tips_for_printf(void);

void main(void)
{
    int age_a, age_b, age_c, age_d;
    float f_asset_a, f_asset_b, f_asset_c, f_asset_d;
    double d_asset_a;
    char name_a[10], name_b[10], name_c[10], name_d[10];
    printf("sizeof(f_asset_a): %zd,sizeof(d_asset_a): %zd\n",
     sizeof(f_asset_a), sizeof(d_asset_a));
    printf("input age  asset  name: ");
    // 每个输入项之间至少一个空白(换行符、空格、制表符)
    // scanf()函数使用空白把输入分成多个字段
    // 依次把转换说明和字段匹配时跳过空白
    // 内存区域:
    //  [...|数字字符|空白字符|数字字符|空白字符|字母字符|...]
    // 举例: scanf()函数 使用%d转换说明
    // 我想输入整数32
    // 使用键盘键入文本字符1和8
    //    3        2 
    // 数字字符  数字字符
    // 空白字符会被scanf()函数跳过
    // 遇到第一个数字字符或+/-符号字符开始读取,保存后再读取下一个字符
    // 读取到非数字字符,scanf()函数把非数字字符放回输入
    // 程序下一次读取时,从这个放回的非数字字符读取
    // 因此输入 32 40000fyf (正常的输入方式 -->:32 40000 fyf)
    // scanf()函数读取的结果也是正确的
    scanf("%d %lf %s", &age_a, &d_asset_a, name_a);
    // scanf() double类型转换说明要加修饰符l %lf,与pirntf()不同
    // conversion specification 转换说明
    // modifier 修饰符
    // *《c primer plus第六版》P220 scanf()转换说明,修饰符
    printf("Age: %d, Asset: %.2f, Name: %s\n", age_a, d_asset_a, name_a);
    // 打印变量的指针(地址)  
    // %p 指针
    printf("integer variable age virtual address: %p\n", &age_a);
    // %s %d 转换说明顺序
    // scanf()函数先读取非空白字符,读取一个,保存,再读取下一个字符
    // 读取到空白字符,读取结束(与转换说明%s匹配的字符串字段读取结束)
    // 再读取下一个与转换说明%d匹配的整数字段
    printf("input name age: ");
    scanf("%s %d", name_b, &age_b);
    printf("Name: %s, Age: %d\n", name_b, age_b);
    // %d %s 转换说明顺序
    // 如果输入A,scanf()函数读取到A后,将停止读取,并将A放回输入
    // 不会把值赋给指定变量
    // ***如果scanf()函数带多个转换说明,C规定在第一个出错处停止读取输入(后面的读取全部停止)
    printf("input age name: ");
    scanf("%d %s", &age_c, name_c);
    printf("Age: %d, Name: %s\n", age_c, name_c);
    
    printf("age(%%d): %d\n", age_d);
    printf("age(%%x): %x\n", age_d);
    printf("&age(%%x): %x\n", &age_d);
    // %d 一个转换说明(注:这里假设每个scanf函数只有一个转换说明,因此一次读取就是一个scanf函数调用)
    // 输入A,scanf()函数停止读取,把A字符放回输入
    // 程序下一次读取时,从这个A字符开始读取
    // 如果程序只有%d输入转换符,scanf()函数就一直无法越过A字符
    printf("input age: ");
    scanf("%d", &age_d);
    printf("age(%%d): %d\n", age_d);
    printf("age(%%x): %x\n", age_d);
    printf("&age(%%x): %x\n", &age_d);
    
    // %s
    // scanf()函数跳过空白字符,直到遇到第一个非空白字符
    // 读取,保存,再读取下一个字符,保存
    // 直到再次遇到空白字符,这个空白字符不保存
    // (这个空白字符放不放回输入不知道,书上没写。。。不过放不放也没啥意义)
    printf("input name: ");
    scanf("%s", &name_d);
    printf("name_d(%%s): %s\n", name_d);
    scanf_format_character_string();
    scanf_conversion_specification_character();
    //scanf_return_value();
    printf_star_modifier();
    scanf_star_modifier();
    usage_tips_for_printf();
    return;
}
// 注: 在C语言中,scanf()并不是最常用的输入函数,但它能读取不同类型的数据
//     C语言还有其它的输入函数,例如: getchar()和fgets(),会在后面的章节中介绍

void scanf_format_character_string(void)
{
    int i_sfcs_a, i_sfcs_b, i_sfcs_c, i_sfcs_d;
    // scanf函数允许在格式字符串中加入普通字符
    // * 空白字符包括(空格字符,制表字符,换行字符和没有空白字符的特殊情况)
    printf("input i_sfcs_a(int), i_sfcs_b(int);");
    printf("(%%d,%%d): ");
    //scanf(",%d%d", &i_sfcs_a, &i_sfcs_b);
    //从上一个回车键输入后已经开始读取
    //回车键产生的换行符与,逗号不匹配,多个转换说明,
    //根据C标准规定,这个scanf函数直接停止读取 
    //*因此普通字符并不像转换说明一样(前面加空白字符的特殊情况:即不加空白字符)可以跳过空白字符然后读取
    //要解决这个问题,在普通字符前加空白字符(非特殊情况),解决方法如下
    //scanf(" ,%d%d", &i_sfcs_a, &i_sfcs_b);
    scanf("%d,%d", &i_sfcs_a, &i_sfcs_b);
    printf("i_a,i_b: %d,%d\n", i_sfcs_a, i_sfcs_b);
    //scanf格式字符串中,[转换说明前]加空白字符(包括无空白字符的特殊情况,就是无字符)
    //[转换说明前]加空白字符包括特殊情况作用是匹配输入项时跳过空白字符.
    //scanf格式字符串中,转换说明加普通字符
    //输入时格式要与scanf格式字符串的格式相匹配,
    //才能让scanf函数能够从缓冲区中正确读取数据
    //* 简单说,转换说明前有空白字符(包括无空白字符的特殊情况),
    //  scanf函数读取输入时就会跳过输入到缓冲区的空白字符
    //* 转化说明之间有普通字符,输入时就要输入普通字符与格式字符串匹配
    //例如: scanf("%d,%d");  第一个输入项: 32,
    //输入:(读取时跳过空白字符)整数类型|,逗号|(读取时跳过空白字符)整数类型
    // 注: 第二个%d匹配输入项,后面可以输入空字符,scanf读取第二个整数输入项时,
    // 遇到空白字符,会停止第二个输入项的数据读取,把空字符放回输入缓冲区,下一次读取时从这个空白字符读取 
    printf("input i_sfcs_a(int), i_sfcs_b(int);");
    printf("(%%d : %%d): ");
    scanf("%d : %d", &i_sfcs_c, &i_sfcs_d);
    printf("%d %d\n", i_sfcs_c, i_sfcs_d);
    return;
}

void scanf_conversion_specification_character(void)
{
    int i_a, i_b, i_c, i_d;
    char c_a, c_b;

    printf("input int i_a i_b(%%d%%d):");
    scanf("%d%d", &i_a, &i_b);
    printf("%d,%d\n", i_a, i_b);
    printf("input int i_a i_b(%%d %%d):");
    scanf("%d %d", &i_c, &i_d);
    printf("%d,%d\n", i_c, i_d);
    
    // %c与普通字符情况一样,前面加空白字符的特殊情况(即不加空白字符)
    // 都是不会跳过输入时的空白字符的
    // scanf("%c") 和scanf(" %c")是有区别的 
    // (注: scanf函数的%c是特殊情况,其它转换说明无这种区别)
    // %c读取一个字符,包括回车键生成的换行符
    // 假设执行到上一个scanf函数,我们输入数据,按回车,
    // 生成的换行字符会存入输入缓冲区
    // scanf("%c")会读取这个换行字符
    // scanf(" %c")则可正确读取,不会读取输入缓冲区中的换行字符(ascii码)
    // scanf转换说明前没有空格
    printf("input char c_a(%%c):");
    scanf("%c", &c_a);
    printf("c_a(%%c):%c\n", c_a);
    //换行符ascii码是10,C语言换行符是'\n'
    //空格符(space)ascii码是32
    printf("c_a(%%hhu):%hhu\n", c_a);
    // scanf转换说明前有空格
    printf("input char c_b( %%c):");
    scanf(" %c", &c_b);
    printf("c_b(%%c):%c\n", c_b);
    // 'A' ascii码是65
    // %hhu printf和scanf都有这个转换说明
    // 作用:输出或输入一个一个字节的无符号整数
    printf("c_b(%%hhu):%hhu\n", c_b);
    return;
}

// 总结: %d 转换说明匹配输入项
//       |空白字符前|整数类型数据|空白字符后|
//                 |           |
//跳过空白字符   读取开始     读取结束    读到空白字符后,放回输入缓存区
//程序有下一个scanf函数的话,从放回的空白字符开始读取
//
// scanf 转换说明  例如: scanf("%d"); 和 scanf(" %d"); 是等价的
// scanf格式字符串的空白字符(包括无空白字符的特殊情况)作用是跳过输入缓冲区的空白字符
// %c 是个例外  scanf("%c"); 和 scanf(" %c"); 是不等价的
// scanf格式字符串中的普通字符,输入时要输入相匹配的普通字符,不匹配的话会停止读取
// 普通字符并不会被保存,只有与转换说明相匹配的输入被保存到指定变量
// scanf只有单个转换说明,输入不匹配,scanf会停止读取,程序有下一个scanf的话,下一个scanf继续读取
// scanf如果有多个转换说明,输入不匹配的话,C标准规定程序停止读取,即使后面代码中还有scanf

//void scanf_return_value(void)
//{
//    //scanf返回值为int类型
//    // 转义序列(escape sequence)    
//    // \" 反斜杠后面的字符,不是它ascii字符本来的意思了
//    // " C中原意是字符串符号, \" 转义序列,意思是双引号符号字符本身 
//    // %d 转换说明,转换成整数类型
//    // %% 转换说明,转换成百分号字符本身
//}

// * modifier   *修饰符
// printf("%*d", width, integer);   *表示字段宽度,不想预先指定字段宽度时用*代替
void printf_star_modifier(void)
{
    unsigned int before, after;
    double d_a = 1111111.1111;
    printf("input width before/after decimal point: ");
    scanf("%d %d", &before, &after);
    // %*.*f  第一个*表示浮点数字段宽度,位数不足的填充空格,位数足够或超过的原样输出即可
    //        第二个*表示浮点数小数点后保留位数
    printf("%*.*f\n", before, after, d_a);
    return;
}

void scanf_star_modifier(void)
{
    int ssm_i_a;
    //scanf的*修饰符与printf的*修饰符作用不同
    //scanf("%*d%*d%d", &int);
    //读取输入缓冲区时,跳过前两个输入项,读取和保存第三个输入项到指定变量
    printf("&ssm_i_a(%%*d%%*d%%d): ");
    scanf("%*d%*d%d", &ssm_i_a);
    printf("ssm_i_a(%%d): %d\n", ssm_i_a);
    return;
}

// usage 用法
void usage_tips_for_printf(void)
{
    int utfp_i_a, utfp_i_b, utfp_i_c, utfp_i_d, utfp_i_e, utfp_i_f,\
     utfp_i_g, utfp_i_h, utfp_i_i, utfp_i_j, utfp_i_k, utfp_i_l;
    
    printf("input(%%d %%d %%d %%d %%d %%d): ");
    scanf("%d %d %d %d %d %d",
     &utfp_i_a, &utfp_i_b, &utfp_i_c, &utfp_i_d, &utfp_i_e, &utfp_i_f);
    printf("input(%%d %%d %%d %%d %%d %%d): ");
    scanf("%d %d %d %d %d %d",
     &utfp_i_g, &utfp_i_h, &utfp_i_i, &utfp_i_j, &utfp_i_k, &utfp_i_l);
    
    printf("%d %d %d %d %d %d\n",
     utfp_i_a, utfp_i_b, utfp_i_c, utfp_i_d, utfp_i_e, utfp_i_f);
    printf("%8d %8d %8d %8d %8d %8d\n",
     utfp_i_a, utfp_i_b, utfp_i_c, utfp_i_d, utfp_i_e, utfp_i_f);
    return;
}



```


## 9. while 宏定义
```c
#include <stdio.h>
//定义符号常量,预编译时后面的字符串替换前面的符号常量(文本)
#define OPERATORS "= + - * /"
#define SECOND_PER_MINUTE 60
void while_block(void);
void addition_substraction_operator(void);
void sign_operator(void);
void sixty_four_game(void);
void multiplication_division_operator(void);
void operator_precedence(void);
void sizeof_operator_and_size_type(void);
void second_to_minute(void);

int main(void)
{
    // operator:运算符; expression:表达式; statement:语句;
    // operand:运算数,操作数;
    // = 赋值运算符(assignment operator)
    //格式字符串中的转换说明%s,后面的待输出项类型和熟练要与转换说明相匹配
    printf("These is operators: %s\n", OPERATORS);
    while_block();
    addition_substraction_operator();
    sign_operator();
    sixty_four_game();
    multiplication_division_operator();
    operator_precedence();
    sizeof_operator_and_size_type();
    second_to_minute();
    return 0;
}

void while_block(void)
{
    //这里的 =运算符 表示 初始化而不是 赋值
    const int ONE = 1;
    
    //把整数值0赋给变量start,赋值表达式
    // 可修改的左值 = 表达式的值(包括常量,变量,可求值的表达式) 
    int start = 0;
    // C的当前标准
    //(早期C标准的lvalue: left value
    //,rvalue: right value的定义已经不能满足当前的状况)
    // 左:
    //  *modifiable lvalue(可修改的左值)
    //  object locator value(对象定位值)
    // 右:
    //  *value of an expression(表达式的值)
    //  包括常量,变量,可求值的表达式
    //《c primer plus第六版》中文版的定义:
    //赋值语句的目的是把值储存到内存位置,储存值的内存存储区域称为数据对象(data object)
    //我自己根据《c primer plus第六版》英文版的翻译
    //考虑一个赋值语句.它的目的是储存一个值在一个内存位置.
    //数据对象是一个 用于存储整个值的数据存储区域的 通用术语

    while (start<10)/* starting the while loop  */
    //花括号之间的内容是要被重复的内容,用计算机术语说,就是程序循环这些语句
    /* start of block,花括号以及花括号括起来的部分被称为block */
    {                           
    // 目前个人的理解,下面整句为赋值语句,
    // start + 1为表达式的值(可求值的表达式),它是程序计算的一个临时值,之后会被丢弃,应该是赋值给左值后丢弃吧,个人推测... 
    // 常量是由系统在main函数运行前把常量赋值给常量的...(网上的说法,也不知道对错,待以后验证吧...)
    // 只有变量是可以引用内存地址的(个人理解,待验证,目前知识水平有限...)
        start = start + 1;      
    // operand(the item项 to the left of =) = operator operate on
    //    操作数(运算数)[赋值运算符左侧的项]  = 操作数(运算数) 操作符(运算符)操作(运算) 操作数(运算数)
    //    modifiable lvalue(可修改的左值)   =  操作数(运算数) 操作符(运算符)操作(运算) 操作数(运算数)
        printf("%d\n", start);
    }                           /* end of block */
    printf("The End!\n");
    return;
}

//addition operator和subtraction operator称为bianry operator(二次元...哦,不,二元运算符XD)
//即这些运算符需要两个运算数(operand)才能完成运算
void addition_substraction_operator(void)
{
    int ao_i_a, ao_i_b, ao_i_c;
    //assignment statment,赋值语句;assigement operator,赋值运算符;
    //可修改的左值(modifiable lvalue) = 表达式的值(an value of expression)(变量,常量,可求值的表达式)
    ao_i_a = 2;
    ao_i_b = 1;
    // 关键知识点:
    // * ao_i_a + ao_i_b表达式,程序计算的一个临时值,计算完成后会被丢弃,它并不能表示特定的内存位置,
    // * 个人推理:计算出的临时值,应该直接从寄存器直接赋给变量(可修改的左值的内存存储区域:数据对象)了,很合理吧...
    // * 因此不能赋值给它
    ao_i_c = ao_i_a + ao_i_b;
    printf("ao_i_a + ao_i_b = %d\n", ao_i_c);
    ao_i_c = ao_i_a - ao_i_b;
    printf("ao_i_a - ao_i_b = %d\n", ao_i_c);
    return;
}

// sign operator(符号运算符): + 和 -
// unary operator(一元运算符),完成运算只需要一个运算数(operand)
void sign_operator(void)
{
    int so_i_a, so_i_b;
    so_i_a = 5;
    so_i_b = -so_i_a;
    printf("so_i_b = -so_i_a = %d\n", so_i_b);
    return;
}

// count初始化等于1
// while循环,循环一次,count+1
// 循环1:  count = 2
// 循环2:  count = 3
//  ... ...
// 循环63: count = 64
// 循环条件count<64,语句块循环了63次,count=64,循环停止
void sixty_four_game(void)
{
    int count = 1;
    double number = 1.0, total = 1.0;
    printf("count                ");
    printf("number                     ");
    printf("total\n");
    printf("%3d. %22.1f %25.1f\n", count, number, total);
    while (count<64)
    {
        count = count + 1;
        // * multiplication operator乘法运算符
        number = 2.0 * number;
        total = total + number;
        printf("%3d. %22.1f %25.1f\n", count, number, total);
    }
    printf("The Max of number: %22.1f\n", number);
    printf("The Max of total:  %23.1f\n", total);
    printf("The End!\n");
    return;
}

//*打通数学的任督二脉...
//数学知识温习,前面的c文件也有,但有点难找,懒得翻回去找了...
//数学源于生活-->形象-->抽象
//形象:
// 9 / 3 = 3      1. 9根辣条,分成3份,每份3根
// 9 / 1 = 9      1. 9根辣条,分成1份,每份9根
// 9 / 1/9 = 81   1. 9跟辣条,分成1/9份,每份81根(9根就是1/9份,因此,一份就是81!!!)  
//                   (9除以1/9这个我想了挺久,我感觉这个形象最靠谱...)
//抽象: 
// 在代数体系中,除法,减法的定义
// 除于一个数等于乘于这个数的乘法逆元(倒数)
// 减去一个数等于加上这个数的加法逆元(相反数)
//division operator除法运算符 /
void multiplication_division_operator(void)
{
    int var;
    //整数除法
    //在C语言中,整数除法的计算结果小数部分会被丢弃,称为截断(truncation)
    //C99规定 趋零截断
    printf("7/4 = (%%d): %d\n", 7/4);
    printf("7/4 = (hexadecimal): %x \n", 7/4);
    printf("var = 7/4 = (hexadecimal): %x \n", var = 7/4);
    //欠7根辣条,分成4份,每份欠1.75根
    printf("-7/4 = (integer): %d \n", -7/4);
    printf("-7/4 = (hexadecimal): %x \n", -7/4);
    printf("var = -7/4 = (hexadecimal): %x \n", var = -7/4);
    //  7 4bit two's complement: 0111
    // -7 4bit two's complement: 1001
    //  4 4bit two's complement: 0100
    // -4 4bit two's complement: 1100
    //  7/-4  --> 0111/1100 --> 0111/0100 -->
    //           1.11
    //       ____________
    // 0100_/ 0111
    //        0100               下面的注释:除了写明是十进制的,其余的都是二进制数
    //     --------------
    //          11 0         <-- 11 拆成 110份 每份 (1/2)10
    //          10 0
    //     --------------
    //           1 00
    //           1 00        <-- 10份(1/2)10 拆成10份 (1/4)10
    //     --------------
    //              0  
    //    1.11小数部分会被截断(truncation),小数部分丢弃
    //    --> 1 --> 0001 --> 有一个运算数为负数(二补数编码最高位为1) --> 1111
    printf("7/-4 = (%%d): %d\n", 7/-4);
    printf("-7/-4 = (%%d): %d\n", -7/-4);
    
    //浮点数除法
    //浮点数常量为双精度浮点类型double
    printf("sizeof(7.0)(%%zd): %zd\n", sizeof(7.0));
    printf("7.0 = (%%lx):%lx\n", 7.0);
    printf("4.0 = (%%lx):%lx\n", 4.0);
    printf("7.0/4.0 = (%%f) %f\n", 7.0/4.0);
    printf("7.0/4.0 = (%%lx) %lx\n", 7.0/4.0);
    // operand_1: 
    // 7.0 --> 111 * (2^0)10 --规格化--> 1.11 * (2^2)10
    // exponent:  bias_1023 --> 2 + 1023 = 1025 
    //             00000000010      阶码进行二补数运算(非二补数编码运算)
    //          +  01111111111
    //         -----------------
    //             10000000001
    // mantissa: 1.11 --隐含1.--> 1100 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
    // sign   exponent                        mantissa
    //  0   10000000001  1100000000000000000000000000000000000000000000000000     
    // hexadecimal: 401c000000000000
    //
    // operand_2:
    // 4.0 --> 100 * (2^0)10 --规格化--> 1.00 * (2^2)10
    // exponent:  bias_1023 --> 2 + 1023 = 1025 
    //             00000000010      阶码进行二补数运算(非二补数编码运算)
    //          +  01111111111
    //         -----------------
    //             10000000001
    // mantissa: 1.00 --隐含1.--> 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
    // sign   exponent                        mantissa
    //  0   10000000001  0000000000000000000000000000000000000000000000000000     
    // hexadecimal: 4010000000000000
    //
    // operand_1 / operand_2:
    //   1.11 * (2^2)10 / 1.00 * (2^2)10
    // = 111 / 100 = 1.11  -->  1.11 * (2^0)10
    // exponent:  bias_1023 --> 0 + 1023 = 1023 
    //             00000000000      阶码进行二补数运算(非二补数编码运算)
    //          +  01111111111
    //         -----------------
    //             01111111111
    // mantissa: 1.11 --隐含1.--> 1100 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
    // sign   exponent                        mantissa
    //  0   01111111111  1100000000000000000000000000000000000000000000000000     
    // hexadecimal: 3ffc000000000000
    //
    // * 整数和浮点数乘除法:
    // * 关于sign的问题,乘法或除法,有一个operand为负,则运算结果sign为1;
    // *               两个operand都为正或都为负,则运算结果sign为0;
    // * 乘除法: 直接乘除
    // * 加减法: exponent转换成与大的expoent一致,尾数进行加减运算
    //CPU ALU(算术逻辑单元)必须按这个数学运算规则来实现乘除运算
    //只能根据C标准的浮点数存储格式和算法算出结果,但运算过程怎么实现的目前还不知道
    //(数字电路还没学,只有一点浅薄的硬件知识,理解未必正确或精准)
    //
    //            ______
    //      1.1 _/ 11.01
    //   11.01/1.1 = 11.01*10/1.1*10 = 110.1/11
    //
    printf("-7.0/4.0 = %f\n", -7.0/4.0);
    printf("-7.0/4.0 = %lx\n", -7.0/4.0);
    printf("7.0/-4.0 = %f\n", 7.0/-4.0);
    printf("7.0/-4.0 = %lx\n", 7.0/-4.0);
    printf("-7.0/-4.0 = %f\n", -7.0/-4.0);
    printf("-7.0/-4.0 = %lx\n", -7.0/-4.0);
    //浮点数整数混合,一般情况下,还是要避免这种情况
    //计算机并不能真正浮点数和整数相除,浮动数和整数在内存中的存储方式完全不同
    //下面两句代码中,在进行除法运算前,编译器会把整数转换为浮点数
    printf("6.0/3 = %f\n", 6.0/3);
    printf("6/3.0 = %f\n", 6/3.0);
    return;
}

// *乘法与除法运算,同号为正,异号为负(不深究的话其实记住这个就足够了)
//如果要刨根问底,这就说来话长了...
//
//预备知识:
//  N自然数包括 0,正整数 (N*,N+非零自然数,正整数)
//  Z整数包括 负整数,0,正整数
//     N+正整数集合,在加法运算下是封闭的,即两个正整数相加还是正整数
//     负整数是有了0之后,从正整数集拓展出来的数(可以看作正整数集关于零的对称集)
//  实数包括 有理数和无理数
//     有理数:包括所有分数,整数, 总能写成整数,有限小数,无限循环小数
//     无理数:无限不循环小数,例如:圆周率,根号2
//
//从自然数集说起...
//自然数集N
//自然数集规定了加法和乘法以后,可以证明:
// 加法对称性: 
// 加法结合律: (1 + 2) + 3 = 1 + (2 + 3)
// 乘法对称性: 
// 乘法结合律: (1 * 2) * 3 = 1 * (2 * 3)
// 乘法对加法的左右分配律:  (2 + 5)*2 = 2*2 + 5*2
//   2  2  --> 两个2=4  --|
//                        |--> 两个2加两个5 = 14
//   5  5  --> 两个5=10 --|
//   |  |
//   7  7  --> 两个7相加 = 14
//
//非零自然数n的加法逆元是-n,称为"负整数"
//非零自然数称为"正整数"
//  a + (-b) 简记成 a-b
//减法其实就是加法运算和取逆运算的一个复合
//
//人们希望 加法具有 对称性 和 (乘法)对加法的左右分配律
// x = (-a)*b
//  x + a*b
//= (-a)*b + a*b
//= (-a + a)*b
//= 0*b
//= 0
//人们把(-a)*b定义为a*b的加法逆元,也就是-(a*b)
//异号为负,(-a)*b=a*(-b)=-(a*b)
// x = (-a)*(-b)
//  x + a*b
//= (-a)*(-b) + a*b
//= [(-a)*(-1) + a]*b     --> (-1)*b = -b 结果是b的加法逆元 --> (-1)*(-a) = -(-a) 结果是(-a)的加法逆元
//= [-(-a) + a]b
//= (a + a)b
//= ab + ab
//因此把(-a)*(-b)定义为a*b???这个是我自己推论的,不知道对不对,上面的是知乎大佬的原文...
//啊...不纠结这个了...先跳过这里,以后再深究...
//目前记住乘法和除法同号为正,异号为负就行了... 20200227

// operator precedence 运算符优先级
void operator_precedence(void)
{
    int result;
    //跟数学四则运算规则是一样的,那必须的,要不然有啥意义呢...
    // 优先级: 小括号() > +/-正负符号 > 乘法/除法 > 加法/减法 > =赋值运算符
    // 优先级相同,顺序从左到右 (=运算符除外)
    result = 5 + 2*8/4;
    printf("result(%%d): %d\n", result);
    printf("5 + 2*8/4 =(%%d): %d\n", 5 + 2*8/4);
    printf("5 + 2*8/-4 =(%%d): %d\n", 5 + 2*8/-4);
    printf("%d\n", -(3+2)*6+(4+3*(8+5)));
    //  -(3+2)*6+(4+3*(8+5))
    //= -5*6+(4+3*(8+5))
    //= -5*6+(4+3*13)
    //= -5*6+(4+39)
    //= -5*6+43
    //= -30+43
    //= 13
    return;
}

void sizeof_operator_and_size_type(void)
{
    // size_t类型
    // 文件test7.c中,stdio_include_stddef_size_type()函数的注释中有介绍
    // 目前我正在用的编译器,size_t类型是long unsigned int的底层类型
    // size_t类型让程序的移植性更好,不同编译器的size_t类型的
    // (上层类型不相同,为了更容易描述我自己定义的,并没有上层类型这个概念)
    size_t st;
    printf("sizeof(st): %zd\n", sizeof(st));
    // typedef关键字 可为现有类型创建别名,例如:
    // typedef int integer
    // integer n = 3;
    // 使用size_t类型时,头文件可用typedef关键字根据不同系统替换标准的类型
    return;
}

// % modulus operator求模运算符
// 求模运算符只用于整数
// 左侧整数除以右侧整数的余数
void second_to_minute(void)
{
    int second, min, sec;
    printf("input second(negative number->quit): ");
    // 空白字符包括转换说明前无空白字符的情况(%c除外)
    // 读取输入缓冲区时会自动跳过 非符号字符 和 数字字符
    scanf("%d", &second);
    // * 记住一个重点: 整数常量是有符号整数!!!(无符号整数常量要加后缀u或U)
    //   这样就能清楚知道,整数常量在内存中的储存方式
    //   条件表达式看变量的类型,根据以下规则判断大小即可,OK了~
    // 无符号整数0000最小,1111最大
    // 突然有点明白java为什么没有无符号整型了...
    // 有符号整数0111最大,0000,1000最小
    //    1. 符号位0>1
    //    2. 符号位0,111-->000 由大到小
    //    3. 符号位1,111-->000 由大到小
    //数值位由高位向低位比较,因为1000>0111,
    //因为 后面位值最小的情况 也比 后面位值最大的情况 大
    //所以高位数值大的数,它的值就大
    while (second >= 0)
    {
        // 结果小数截断(truncation)
        // 数学上的除法理解为拆分成60份
        // 这里的除法可以形象化为60一份,最大可以分几份,最小单元为1,不拆分
        min = second / SECOND_PER_MINUTE;
        // 结果为余数
        // 拆分60一份,余下不足60的数
        // / 运算,同号为正,异号为负.  
        // % 运算,第一个运算数为正,则结果为正
        //        第一个运算数为负,则结果为负
        // * C标准规定,可通过 a-(a/b)*b 来计算 a%b  (a,b为整数)
        // 这里的取模运算可以形象化为60一份,最大可以分几份,最小单元为1,不拆分
        // 剩余不足60的余数就是结果
        sec = second % SECOND_PER_MINUTE;
        printf("(minute:second) %d:%d\n", min, sec);
        printf("input second(negative number->quit): ");
        scanf("%d", &second);        
    }
    printf("The End\n");
    return;
}




```



## 10. 
```c


```


## 11. 
```c


```



## 12. 
```c


```


## 13. 
```c


```



## 14. 
```c


```

