# C语言规范
## 1.头文件
若包含了头文件aa.h，则就引入了新的依赖：一旦aa.h被修改，任何直接和间接包含aa.h代码都会被重新编译。如果aa.h又包含了其他头文件如bb.h，那么bb.h的任何改变都将导致所有包含了aa.h的代码被重新编译，在敏捷开发方式下，代码会被频繁构建，漫长的编译时间将极大的阻碍频繁构建。因此，我们倾向于减少包含头文件，尤其是在头文件中包含头文件，以控制改动代码后的编译时间。

合理的头文件划分体现了系统设计的思想，但是从编程规范的角度看，仍然有一些通用的方法，用来合理规划头文件。

* 原则1.1 头文件中适合放置接口的声明，不适合放置实现。

   说明：头文件是模块（Module）或单元（Unit）的对外接口。头文件中应放置对外部的声明，如对外提供的函数声明、宏定义、类型定义等。

   内部使用的函数（相当于类的私有方法）声明不应放在头文件中。
   
   内部使用的宏、枚举、结构定义不应放入头文件中。
   
   变量定义不应放在头文件中，应放在.c文件中。
   
* 原则1.2 头文件应当职责单一。

   说明：头文件过于复杂，依赖过于复杂是导致编译时间过长的主要原因。很多现有代码中头文件过大，职责过多，再加上循环依赖的问题，可能导致为了在.c中使用一个宏，而包含十几个头文件。

* 原则1.3 头文件应向稳定的方向包含。

   产品依赖于平台，平台依赖于标准库。某产品线平台的代码中已经包含了产品的头文件，导致平台无法单独编译、发布和测试，是一个非常糟糕的反例。
   
   除了不稳定的模块依赖于稳定的模块外，更好的方式是两个模块共同依赖于接口，

* 规则1.1 每一个.c文件应有一个同名.h文件，用于声明需要对外公开的接口。

   说明：如果一个.c文件不需要对外公布任何接口，则其就不应当存在，除非它是程序的入口，如main函数所在的文件。

* 规则1.2 禁止头文件循环依赖。

   说明：头文件循环依赖，指a.h包含b.h，b.h包含c.h，c.h包含a.h之类导致任何一个头文件修改，都导致所有包含了a.h/b.h/c.h的代码全部重新编译一遍。
   
* 规则1.3 .c/.h文件禁止包含用不到的头文件。

   说明：很多系统中头文件包含关系复杂，开发人员为了省事起见，可能不会去一一钻研，直接包含一切想到的头文件。
   
* 规则1.4 头文件应当自包含。

   说明：简单的说，自包含就是任意一个头文件均可独立编译。如果一个文件包含某个头文件，还要包含另外一个头文件才能工作的话，就会增加交流障碍，给这个头文件的用户增添不必要的负担。

* 规则1.5 总是编写内部#include保护符（#define 保护）。

   说明：多次包含一个头文件可以通过认真的设计来避免。如果不能做到这一点，就需要采取阻止头文件内容被包含多于一次的机制。
   
   所有头文件都应当使用#define 防止头文件被多重包含，命名格式为FILENAME_H，为了保证唯一性，更好的命名是PROJECTNAME_PATH_FILENAME_H。
   
* 规则1.6 禁止在头文件中定义变量。

   说明：在头文件中定义变量，将会由于头文件被其他.c文件包含而导致变量重复定义。

* 规则1.7 只能通过包含头文件的方式使用其他.c提供的接口，禁止在.c中通过extern的方式使用外部函数接口、变量。

* 规则1.8 禁止在extern "C"中包含头文件。

   说明：在extern "C"中包含头文件，会导致extern "C"嵌套。
   
* 建议1.1 一个模块通常包含多个.c文件，建议放在同一个目录下，目录名即为模块名。为方便外部使用者，建议每一个模块提供一个.h，文件名为目录名。  
   
* 建议1.2 如果一个模块包含多个子模块，则建议每一个子模块提供一个对外的.h，文件名为子模块名。

   说明：降低接口使用者的编写难度。  
   
* 建议1.3 头文件不要使用非习惯用法的扩展名，如.inc。

* 建议1.4 同一产品统一包含头文件排列方式。

## 2.函数
函数设计的精髓：编写整洁函数，同时把代码有效组织起来。

* 1.整洁函数要求：代码简单直接、不隐藏设计者的意图、用干净利落的抽象和直截了当的控制语句将函数有机组织起来。

* 2.代码的有效组织包括：逻辑层组织和物理层组织两个方面。逻辑层，主要是把不同功能的函数通过某种联系组织起来，主要关注模块间的接口，也就是模块的架构。物理层，无论使用什么样的目录或者名字空间等，需要把函数用一种标准的方法组织起来。例如：设计良好的目录结构、函数名字、文件组织等，这样可以方便查找。


* 原则2.1 一个函数仅完成一件功能。

说明：一个函数实现多个功能给开发、使用、维护都带来很大的困难。
将没有关联或者关联很弱的语句放到同一函数中，会导致函数职责不明确，难以理解，难以测试和改动。

如 realloc()函数情况太多，容易发生错误。

```c
char *buffer = (char *)malloc(XXX_SIZE);// 分配内存
//.....
buffer = (char *)realloc(buffer, NEW_SIZE);// 重新分配一块内存
// 如果没有足够可用的内存用来完成重新分配，函数返回为NULL，导致buffer原来指向的内存被丢失。
```

* 原则2.2 重复代码应该尽可能提炼成函数。

说明：重复代码提炼成函数可以带来维护成本的降低。

项目组应当使用代码重复度检查工具，在持续集成环境中持续检查代码重复度指标变化趋势，并对新增重复代码及时重构。当一段代码重复两次时，即应考虑消除重复，当代码重复超过三次时，应当立刻着手消除重复。

一般情况下，可以通过提炼函数的形式消除重复代码。

* 规则2.1 避免函数过长，新增函数不超过50行（非空非注释行）。

说明：本规则仅对新增函数做要求，对已有函数修改时，建议不增加代码行。

过长的函数往往意味着函数功能不单一，过于复杂。函数的有效代码行数，即NBNC（非空非注释行）应当在[1，50]区间。例外：某些实现算法的函数，由于算法的聚合性与功能的全面性，可能会超过50行。
延伸阅读材料：业界普遍认为一个函数的代码行不要超过一个屏幕，避免来回翻页影响阅读；一般的代码度量工具建议都对此进行检查。


* **规则2.2 避免函数的代码块嵌套过深，新增函数的代码块嵌套不超过4层。**

说明：本规则仅对新增函数做要求，对已有的代码建议不增加嵌套层次。

函数的代码块嵌套深度指的是函数中的代码控制块（例如：if、for、while、switch等）之间互相包含的深度。每级嵌套都会增加阅读代码时的脑力消耗，因为需要在脑子里维护一个“栈”（比如，进入条件语句、进入循环„„）。应该做进一步的功能分解，从而避免使代码的阅读者一次记住太多的上下文。

```c
void serial (void)
{
   if (!Received)
   {
      TmoCount = 0;
      switch (Buff)
      {
         case AISGFLG:
            if ((TiBuff.Count > 3)
            && ((TiBuff.Buff[0] == 0xff) || (TiBuf.Buff[0] == CurPa.ADDR)))
            {//串口收到的数据 符合校验规则
               Flg7E = false;
               Received = true;
            }
            else
            {
               TiBuff.Count = 0;
               Flg7D = false;
               Flg7E = true;
            }
            break;
         default:
            break;
      }
   }
}

```

* 规则2.3 可重入函数应避免使用共享变量；若需要使用，则应通过互斥手段（关中断、信号量）对其加以保护。

说明：可重入函数是指可能被多个任务并发调用的函数。在多任务操作系统中，函数具有可重入性是多个任务可以共用此函数的必要条件。共享变量指的全局变量和static变量。
编写C语言的可重入函数时，不应使用static局部变量，否则必须经过特殊处理，才能使函数具有可重入性。

示例：函数square_exam返回g_exam平方值。那么如下函数不具有可重入性。
```c
int g_exam;
unsigned int example( int para )
{
unsigned int temp;
g_exam = para; // （--）
temp = square_exam ( );
return temp;
}
```

此函数若被多个线程调用的话，其结果可能是未知的，因为当（--）语句刚执行完后，另外一个使用本函数的线程可能正好被激活，那么当新激活的线程执行到此函数时，将使g_exam赋于另一个不同的para值，所以当控制重新回到“temp =square_exam ( )”后，计算出的temp很可能不是预想中的结果。此函数应如下改进。

```c
int g_exam;
unsigned int example( int para )
{
unsigned int temp;
[申请信号量操作] // 若申请不到“信号量”，说明另外的进程正处于
g_exam = para;  // 给g_exam赋值并计算其平方过程中（即正在使用此
temp = square_exam( ); // 信号），本进程必须等待其释放信号后，才可继续执行。
[释放信号量操作] // 其它线程必须等待本线程释放信号量后才能再使用本信号。
return temp;
}
```

* 规则2.4 对参数的合法性检查，由调用者负责还是由接口函数负责，应在项目组/模块内应统一规定。缺省由调用者负责。

说明：对于模块间接口函数的参数的合法性检查这一问题，往往有两个极端现象，即：要么是调用者和被调用者对参数均不作合法性检查，结果就遗漏了合法性检查这一必要的处理过程，造成问题隐患；要么就是调用者和被调用者均对参数进行合法性检查，这种情况虽不会造成问题，但产生了冗余代码，降低了效率。

如果函数的参数比较多，而且判断的条件比较复杂（比如：一个整形数字需要判断范围等），那么冗余的代码会大面积充斥着业务代码。

* 规则2.5 对函数的错误返回码要全面处理。

说明：一个函数（标准库中的函数/第三方库函数/用户定义的函数）能够提供一些指示错误发生的方法。这可以通过使用错误标记、特殊的返回数据或者其他手段，不管什么时候函数提供了这样的机制，调用程序应该在函数返回时立刻检查错误指示。

示例：下面的代码导致宕机

```c
FILE *fp = fopen( "./writeAlarmLastTime.log","r");
if(fp == NULL)
{
   return;
}
char buff[128] = "";
fscanf(fp,“%s”, buff); /* 读取最新的告警时间；由于文件writeAlarmLastTime.log为空，导致buff为空 */
fclose(fp);
long fileTime = getAlarmTime(buff); /* 解析获取最新的告警时间；getAlarmTime函数未检查buff指针，导致宕机 */
```

正确写法：

```c
FILE *fp = fopen( "./writeAlarmLastTime.log","r");
if(fp == NULL)
{
   return;
}
char buff[128] = "";
if (fscanf(fp,“%s”,buff) == EOF) // 检查函数fscanf的返回值，确保读到数据,确保buff合理
{
   fclose(fp);
   return;
}
fclose(fp);
long fileTime = getAlarmTime(buff); //解析获取最新的告警时间；
```
* 规则2.6 设计 **高扇入，合理扇出（小于7）的函数**

说明：扇出是指一个函数直接调用（控制）其它函数的数目，而扇入是指有多少上级函数调用它。

扇出过大，表明函数过分复杂，需要控制和协调过多的下级函数；而扇出过小，例如：总是1，表明函数的调用层次可能过多，这样不利于程序阅读和函数结构的分析，并且程序运行时会对系统资源如堆栈空间等造成压力。通常函数比较合理的扇出（调度函数除外）通常是3~5。

扇出太大，一般是由于缺乏中间层次，可适当增加中间层次的函数。扇出太小，可把下级函数进一步分解多个函数，或合并到上级函数中。当然分解或合并函数时，不能改变要实现的功能，也不能违背函数间的独立性。
扇入越大，表明使用此函数的上级函数越多，这样的函数使用效率高，但不能违背函数间的独立性而单纯地追求高扇入。公共模块中的函数及底层函数应该有较高的扇入。
较良好的软件结构通常是顶层函数的扇出较高，中层函数的扇出较少，而底层函数则扇入到公共模块中。

扇入（Fan-in）和扇出（Fan-out）是Henry和Kafura在1981年引入，用来说明模块间的耦合（coupling），后面人们扩展到函数/方法、模块/类、包等。

* 规则2.7 废弃代码（没有被调用的函数和变量)要及时清除。

说明：程序中的废弃代码不仅占用额外的空间，而且还常常影响程序的功能与性能，很可能给程序的测试、维护等造成不必要的麻烦。

* 建议2.1 函数不变参数使用const。

说明：不变的值更易于理解/跟踪和分析，把const作为默认选项，在编译时会对其进行检查，使代码更牢固/更安全。

```c
// 示例：C99标准 7.21.4.4 中strncmp 的例子，不变参数声明为const。
int strncmp(const char *s1, const char *s2, register size_t n)
{// 两个字符串是否相等
   register unsigned char u1, u2;
   while (n-- > 0)
   {
      u1 = (unsigned char) *s1++;// 去除每个对应的字符
      u2 = (unsigned char) *s2++;
      if (u1 != u2)
      {
         return u1 - u2;
      }
      if (u1 == '\0')
      {
         return 0;
      }
   }
   return 0;
}

```

* 建议2.2 函数应避免使用全局变量、静态局部变量和I/O操作，不可避免的地方应集中使用。

说明：带有内部“存储器”的函数的功能可能是不可预测的，因为它的输出可能取决于内部存储器（如某标记）的状态。这样的函数既不易于理解又不利于测试和维护。在C语言中，函数的static局部变量是函数的内部存储器，有可能使函数的功能不可预测，然而，当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类，则返回为错针。

示例：如下函数，其返回值（即功能）是不可预测的。
```c
unsigned int integer_sum( unsigned int base )
{
   unsigned int index;
   static unsigned int sum = 0;// 注意，是static类型的。
   // 若改为auto类型，则函数即变为可预测。
   for (index = 1; index <= base; index++)
   {
      sum += index;
   }
   return sum;
}
```

* 建议2.3 检查函数所有非参数输入的有效性，如数据文件、公共变量等。

说明：函数的输入主要有两种：一种是参数输入；另一种是全局变量、数据文件的输入，即非参数输入。函数在使用输入参数之前，应进行有效性检查。

示例：下面的代码导致宕机
```c
hr = root_node->get_first_child(&log_item); // list.xml 为空，导致读出log_item为空
...
hr = log_item->get_next_sibling(&media_next_node); // log_item为空，导致宕机
```
正确写法：确保读出的内容非空。
```c
hr = root_node->get_first_child(&log_item);
...
if (log_item == NULL) // 确保读出的内容非空=!!!!=
{
   return retValue;
}
hr = log_item->get_next_sibling(&media_next_node);
```

* 建议2.4 函数的参数个数不超过5个。

说明：函数的参数过多，会使得该函数易于受外部（其他部分的代码）变化的影响，从而影响维护工作。函数的参数过多同时也会增大测试的工作量。

函数的参数个数不要超过5个，如果超过了建议拆分为不同函数。


* 建议2.5 除打印类函数外，不要使用可变长参函数。

说明：可变长参函数的处理过程比较复杂容易引入错误，而且性能也比较低，使用过多的可变长参函数将导致函数的维护难度大大增加。


* 建议2.6 在源文件范围内声明和定义的所有函数，除非外部可见，否则应该增加static关键字。

说明：如果一个函数只是在同一文件中的其他地方调用，那么就用static声明。使用static确保只是在声明它的文件中是可见的，并且避免了和其他文件或库中的相同标识符发生混淆的可能性。

建议定义一个STATIC宏，在调试阶段，将STATIC定义为static，版本发布时，改为空，以便于后续的打热补丁等操作。

```c
#ifdef _DEBUG
#define STATIC static
#else
#define STATIC
#endif
```


## 3.标识符命名与定义
### 3.1 通用命名规则

* 1. unix like风格：

单词用小写字母，每个单词直接用下划线„_‟分割，例如text_mutex, kernel_text_address。

* 2. Windows风格：

大小写字母混用，单词连在一起，每个单词首字母大写。不过Windows风格如果遇到大写专有用语时会有些别扭，例如命名一个读取RFC文本的函数，命令为ReadRFCText，看起来就没有unix like的read_rfc_text清晰了。

* 3. 匈牙利命名法是计算机程序设计中的一种命名规则，用这种方法命名的变量显示了其数据类型。

匈牙利命名主要包括三个部分：基本类型、一个或更多的前缀、一个限定词。这种命令法最初在20世纪80年代的微软公司广泛使用，并在win32API和MFC库中广泛的使用，但匈牙利命名法存在较多的争议.

标识符的命名规则历来是一个敏感话题，典型的命名风格如unix风格、windows风格等等，从来无法达成共识。实际上，各种风格都有其优势也有其劣势，而且往往和个人的审美观有关。我们对标识符定义主要是为了让团队的代码看起来尽可能统一，有利于代码的后续阅读和修改，产品可以根据自己的实际需要指定命名风格，规范中不再做统一的规定。

* 原则3.1 标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解。

说明：尽可能给出描述性名称，不要节约空间，让别人很快理解你的代码更重要。

示例：好的命名：
```c
int error_number;
int number_of_completed_connection;
```

不好的命名：使用模糊的缩写或随意的字符：
```c
int n;
int nerr;
int n_comp_conns;

```

* 原则3.2 除了常见的通用缩写以外，不使用单词缩写，不得使用汉语拼音。

说明：较短的单词可通过去掉“元音”形成缩写，较长的单词可取单词的头几个字母形成缩写，一些单词有大家公认的缩写，常用单词的缩写必须统一。协议中的单词的缩写与协议保持一致。对于某个系统使用的专用缩写应该在注视或者某处做统一说明。

```c
示例：一些常见可以缩写的例子：
argument 可缩写为 arg
buffer 可缩写为 buff
clock 可缩写为 clk
command 可缩写为 cmd
compare 可缩写为 cmp
configuration 可缩写为 cfg
device 可缩写为 dev
error 可缩写为 err
hexadecimal 可缩写为 hex
increment 可缩写为 inc、
initialize 可缩写为 init
maximum 可缩写为 max
message 可缩写为 msg
minimum 可缩写为 min
parameter 可缩写为 para
previous 可缩写为 prev
register 可缩写为 reg
semaphore 可缩写为 sem
statistic 可缩写为 stat
synchronize 可缩写为 sync
temp 可缩写为 tmp
```

* 规则3.1 产品/项目组内部应保持统一的命名风格。

说明：Unix like和windows like风格均有其拥趸，产品应根据自己的部署平台，选择其中一种，并在产品内部保持一致。

例外：即使产品之前使用匈牙利命名法，新代码也不应当使用。

* 建议3.1 用正确的反义词组命名具有互斥意义的变量或相反动作的函数等。

示例：
```c
add/remove          begin/end   create/destroy
insert/delete       first/last  get/release
increment/decrement put/get     add/delete
lock/unlock         open/close  min/max
old/new             start/stop  next/previous
source/target       show/hide   send/receive
source/destination  copy/paste  up/down
```

* 建议3.2 尽量避免名字中出现数字编号，除非逻辑上的确需要编号。

示例：如下命名，使人产生疑惑。
```c
#define EXAMPLE_0_TEST_
#define EXAMPLE_1_TEST_
```
应改为有意义的单词命名
```c
#define EXAMPLE_UNIT_TEST_
#define EXAMPLE_ASSERT_TEST_
```

* 建议3.3 标识符前不应添加模块、项目、产品、部门的名称作为前缀。

说明：很多已有代码中已经习惯在文件名中增加模块名，这种写法类似匈牙利命名法，导致文件名不可读，并且带来带来如下问题：

* 1.第一眼看到的是模块名，而不是真正的文件功能，阻碍阅读；
* 2.文件名太长；
* 3.文件名和模块绑定，不利于维护和移植。若foo.c进行重构后，从a模块挪到b模块，若foo.c中有模块名，则需要将文件名从a_module_foo.c改为b_module_foo.c

* 建议3.4 平台/驱动等适配代码的标识符命名风格保持和平台/驱动一致。

说明：涉及到外购芯片以及配套的驱动，这部分的代码变动（包括为产品做适配的新增代码），应该保持原有的风格。

* 建议3.5 重构/修改部分代码时，应保持和原有代码的命名风格一致。

说明：根据源代码现有的风格继续编写代码，有利于保持总体一致。

### 3.2 文件命名规则

* 建议3.6 文件命名统一采用小写字符。

说明：因为不同系统对文件名大小写处理会不同（如MS的DOS、Windows系统不区分大小写，但是Linux系统则区分），所以代码文件命名建议统一采用全小写字母命名。

### 3.3 变量命名规则

* 规则3.2 全局变量应增加“g_”前缀。
* 规则3.3 静态变量应增加“s_”前缀。

说明：增加g_前缀或者s_前缀，原因如下：

首先，全局变量十分危险，通过前缀使得全局变量更加醒目，促使开发人员对这些变量的使用更加小心。

其次，从根本上说，应当尽量不使用全局变量，增加g_和s_前缀，会使得全局变量的名字显得很丑陋，从而促使开发人员尽量少使用全局变量。

* 规则3.4 禁止使用单字节命名变量，但允许定义i、j、k作为局部循环变量。

* 建议3.7 不建议使用匈牙利命名法。

说明：变量命名需要说明的是变量的含义，而不是变量的类型。在变量命名前增加类型说明，反而降低了变量的可读性；更麻烦的问题是，如果修改了变量的类型定义，那么所有使用该变量的地方都需要修改。
匈牙利命名法源于微软，然而却被很多人以讹传讹的使用。而现在即使是微软也不再推荐使用匈牙利命名法。历来对匈牙利命名法的一大诟病，就是导致了变量名难以阅读，这和本规范的指导思想也有冲突，所以本规范特意强调，变量命名不应采用匈牙利命名法，而应想法使变量名为一个有意义的词或词组，方便代码的阅读。

* 建议3.8 使用名词或者形容词＋名词方式命名变量。

### 3.4 函数命名规则

* 建议3.9 函数命名应以函数要执行的动作命名，一般采用动词或者动词＋名词的结构。

示例：找到当前进程的当前目录

DWORD GetCurrentDirectory( DWORD BufferLength, LPTSTR Buffer );

* 建议3.10 函数指针除了前缀，其他按照函数的命名规则命名。

### 3.5 宏的命名规则

* 规则3.5 对于数值或者字符串等等常量的定义，建议采用全大写字母，单词之间加下划线„_‟的方式命名（枚举同样建议使用此方式定义）。

示例：
```c
#define PI_ROUNDED 3.14
```
* 规则3.6 除了头文件或编译开关等特殊标识定义，宏定义不能使用下划线„_‟开头和结尾。

说明：一般来说，‟_‟开头、结尾的宏都是一些内部的定义.

## 4.变量

* 原则4.1 一个变量只有一个功能，不能把一个变量用作多种用途。

说明：一个变量只用来表示一个特定功能，不能把一个变量作多种用途，即同一变量取值不同时，其代表的意义也不同。

示例：具有两种功能的反例.

```c
WORD DelRelTimeQue(void)
{
WORD Locate;
Locate = 3;// 删除元素在队列中的位置
Locate = DeleteFromQue(Locate); /* Locate具有两种功能：位置 和 函数DeleteFromQue的返回值 */
return Locate; // 函数返回值，是否成功等
}
```

正确做法：使用两个变量
```c
WORD DelRelTimeQue(void)
{
WORD Ret;// 函数返回值，是否成功等
WORD Locate;// 删除元素在队列中的位置
Locate = 3;
Ret = DeleteFromQue(Locate);
return Ret;
}
```

* 原则4.2 结构功能单一；不要设计面面俱到的数据结构。

* 说明：相关的一组信息才是构成一个结构体的基础，结构的定义应该可以明确的描述一个对象，而不是一组相关性不强的数据的集合。

设计结构时应力争使结构代表一种现实事务的抽象，而不是同时代表多种。结构中的各元素应代表同一事务的不同侧面，而不应把描述没有关系或关系很弱的不同事务的元素放到同一结构中。

示例：如下结构不太清晰、合理。
```c
typedef struct STUDENT_STRU
{
unsigned char name[32]; /* student's name 姓名*/
unsigned char age; /* student's age  年龄*/
unsigned char sex; /* student's sex, as follows 性别 */
/* 0 - FEMALE; 1 - MALE */

unsigned char teacher_name[32]; /* the student teacher's name 老师的名字*/
unsigned char teacher_sex; /* his teacher sex 老师的性别*/
} STUDENT;

```

若改为如下，会更合理些。
```c
// 老师信息结构体
typedef struct TEACHER_STRU
{
   unsigned char name[32]; /* teacher name 老师的名字*/
   unsigned char sex; /* teacher sex, as follows 老师的性别*/
   /* 0 - FEMALE; 1 - MALE */
   unsigned int teacher_ind; /* teacher index 老师编号*/
} TEACHER;

// 学生信息结构体
typedef struct STUDENT_STRU
{
unsigned char name[32]; /* student's name 名字*/
unsigned char age; /* student's age 年龄*/
unsigned char sex; /* student's sex, as follows 性别*/
/* 0 - FEMALE; 1 - MALE */

unsigned int teacher_ind; /* his teacher index学生老师的编号 */
} STUDENT;
```

* 原则4.3 不用或者少用全局变量。

说明：**单个文件内部可以使用static的全局变量，可以将其理解为类的私有成员变量。**

全局变量应该是模块的私有数据，不能作用对外的接口使用，使用static类型定义，可以有效防止外部文件的非正常访问，建议定义一个STATIC宏，在调试阶段，将STATIC定义为static，版本发布时，改为空，以便于后续的打补丁等操作。

直接使用其他模块的私有数据，将使模块间的关系逐渐走向“剪不断理还乱”的耦合状态，这种情形是不允许的。

* 规则4.1 防止局部变量与全局变量同名。

说明：尽管局部变量和全局变量的作用域不同而不会发生语法错误，但容易使人误解。

* 规则4.2 通讯过程中使用的结构，必须注意字节序。

说明：通讯报文中，字节序是一个重要的问题，我司设备使用的cpu类型复杂多样，大小端、32位/64位的处理器也都有，如果结构会在报文交互过程中使用，必须考虑字节序问题。

由于位域在不同字节序下，表现看起来差别更大，所以更需要注意。

对于这种跨平台的交互，数据成员发送前，都应该进行主机序到网络序的转换；接收时，也必须进行网络序到主机序的转换。

* 规则4.3 严禁使用未经初始化的变量作为右值。

说明：坚持建议4.3（在首次使用前初始化变量，初始化的地方离使用的地方越近越好。）可以有效避免未初始化错误。

* 建议4.1 构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的全局变量，防止多个不同模块或函数都可以修改、创建同一全局变量的现象。

说明：降低全局变量耦合度。

* **建议4.2 使用面向接口编程思想，通过API访问数据：如果本模块的数据需要对外部模块开放，应提供接口函数来设置、获取，同时注意全局数据的访问互斥。**

说明：避免直接暴露内部数据给外部模型使用，是防止模块间耦合最简单有效的方法。
定义的接口应该有比较明确的意义，比如一个风扇管理功能模块，有自动和手动工作模式，那么设置、查询工作模块就可以定义接口为SetFanWorkMode，GetFanWorkMode；查询转速就可以定义为GetFanSpeed；风扇支持节能功能开关，可以定义EnabletFanSavePower等等。

* 建议4.3 在首次使用前初始化变量，初始化的地方离使用的地方越近越好。

说明：未初始化变量是C和C++程序中错误的常见来源。在变量首次使用前确保正确初始化。

在较好的方案中，变量的定义和初始化要做到亲密无间。

```c
示例：
//不可取的初始化：无意义的初始化
int speedup_factor ＝ 0;// 无用
if (condition)
{
   speedup_factor = 2;
}
else
{
   speedup_factor = -1;
}

// 不可取的初始化：初始化和声明分离
int speedup_factor;
if (condition)
{
   speedup_factor = 2;
}
else
{
speedup_factor = -1;
}

//较好的初始化：使用默认有意义的初始化
int speedup_factor = -1;
if (condition)
{
   speedup_factor = 2;
}

//较好的初始化使用?:减少数据流和控制流的混合
int speedup_factor = condition?2:-1;
//较好的初始化：使用函数代替复杂的计算流
int speedup_factor = ComputeSpeedupFactor()；
```

* 建议4.4 明确全局变量的初始化顺序，避免跨模块的初始化依赖。

说明：系统启动阶段，使用全局变量前，要考虑到该全局变量在什么时候初始化，使用全局变量和初始化全局变量，两者之间的时序关系，谁先谁后，一定要分析清楚，不然后果往往是低级而又灾难性的。

* 建议4.5 尽量减少没有必要的数据类型默认转换与强制转换。

说明：当进行数据类型强制转换时，其数据的意义、转换后的取值等都有可能发生变化，而这些细节若考虑不周，就很有可能留下隐患。

示例：如下赋值，多数编译器不产生告警，但值的含义还是稍有变化。
```c
char ch;
unsigned short int exam;
ch = -1;
exam = ch; // 编译器不产生告警，此时exam为0xFFFF。
```


## 5.宏 常量
* 规则5.1 用宏定义表达式时，要使用完备的括号。

说明：因为宏只是简单的代码替换，不会像函数一样先将参数计算后，再传递。

示例：如下定义的宏都存在一定的风险
```c
#define RECTANGLE_AREA(a, b) a * b   //   c/a * b
#define RECTANGLE_AREA(a, b) (a * b) // RECTANGLE_AREA(c + d, e + f)
#define RECTANGLE_AREA(a, b) (a) * (b)
```
正确的定义应为：
```c
#define RECTANGLE_AREA(a, b) ((a) * (b))
```

* **规则5.2 将宏所定义的多条表达式放在大括号中。**

说明：更好的方法是多条语句写成 **do while(0)** 的方式。执行一次

```c
#define FOO(x) do { \
    printf("arg is %s\n", x); \
    do_something_useful(x); \
} while(0)

if (condition == 1)
   FOO(10);
else
   FOO(20);
   
用do-while(0)方式定义宏，完全不用担心使用者如何使用宏，也不用给使用者加什么约束。
```
* 规则5.3 使用宏时，不允许参数发生变化。

示例：如下用法可能导致错误。
```c
#define SQUARE(a) ((a) * (a))
int a = 5;
int b;
b = SQUARE(a++); // 结果：a = 7，即执行了两次增。

// 正确的用法是：
b = SQUARE(a);
a++; // 结果：a = 6，即只执行了一次增。
...
```

* 规则5.4 不允许直接使用魔鬼数字。

说明：使用魔鬼数字的弊端：代码难以理解；如果一个有含义的数字多处使用，一旦需要修改这个数值，代价惨重。

使用明确的物理状态或物理意义的名称能增加信息，并能提供单一的维护点。

解决途径：

对于局部使用的唯一含义的魔鬼数字，可以在代码周围增加说明注释，也可以定义局部const变量，变量命名自注释。

对于广泛使用的数字，必须定义const全局变量/宏；同样变量/宏命名应是自注释的。

0作为一个特殊的数字，作为一般默认值使用没有歧义时，不用特别定义。

* 建议5.1 除非必要，应尽可能使用函数代替宏。

说明：宏对比函数，有一些明显的缺点：
宏缺乏类型检查，不如函数调用检查严格。
宏展开可能会产生意想不到的副作用.

以宏形式写的代码难以调试难以打断点，不利于定位问题。

宏如果调用的很多，会造成代码空间的浪费，不如函数空间效率高。

* 建议5.2 **常量建议使用const定义代替宏。**

说明： “尽量用编译器而不用预处理”，因为#define经常被认为好象不是语言本身的一部分。

看下面的语句：
```c
#define ASPECT_RATIO 1.653
```
编译器会永远也看不到ASPECT_RATIO这个符号名，因为在源码进入编译器之前，它会被预处理程序去掉，于是ASPECT_RATIO不会加入到符号列表中。如果涉及到这个常量的代码在编译时报错，就会很令人费解，因为报错信息指的是1.653，而不是ASPECT_RATIO。如果ASPECT_RATIO不是在你自己写的头文件中定义的，你就会奇怪1.653是从哪里来的，甚至会花时间跟踪下去。这个问题也会出现在符号调试器中，因为同样地，你所写的符号名不会出现在符号列表中。

解决这个问题的方案很简单：不用预处理宏，定义一个常量：

```c
const double ASPECT_RATIO = 1.653;
```

这种方法很有效，但有两个特殊情况要注意。首先，定义指针常量时会有点不同。因为常量定义一般是放在头文件中（许多源文件会包含它），除了指针所指的类型要定义成const外，重要的是指针也经常要定义成const。

例如，要在头文件中定义一个基于char*的字符串常量，你要写两次const：

```c
const char * const authorName = "Scott Meyers";
```

* 建议5.3 宏定义中尽量不使用return、goto、continue、break等改变程序流程的语句。

说明：如果在宏定义中使用这些改变流程的语句，很容易引起资源泄漏问题，使用者很难自己察觉。


## 6.质量保证
* 原则6.1 代码质量保证优先原则

（1）正确性，指程序要实现设计要求的功能。

（2）简洁性，指程序易于理解并且易于实现。

（3）可维护性，指程序被修改的能力，包括纠错、改进、新需求或功能规格变化的适应能力。

（4）可靠性，指程序在给定时间间隔和环境条件下，按设计要求成功运行程序的概率。

（5）代码可测试性，指软件发现故障并隔离、定位故障的能力，以及在一定的时间和成本前提下，进行测试设计、测试执行的能力。

（6）代码性能高效，指是尽可能少地占用系统资源，包括内存和执行时间。

（7）可移植性，指为了在原来设计的特定环境之外运行，对系统进行修改的能力。

（8）个人表达方式/个人方便性，指个人编程习惯。

* 原则6.2 要时刻注意易混淆的操作符。

> 1、易混淆的操作符

赋值操作符“=” 逻辑操作符“==”

关系操作符“<” 位操作符"<<"

关系操作符“>” 位操作符“>>”

逻辑操作符“||” 位操作符"|"

逻辑操作符“&&” 位操作符"&"

逻辑操作符"!" 位操作符“~”

> 2、易用错的操作符

(1) 除操作符"/"

当除操作符“/”的运算量是整型量时，运算结果也是整型。

如:1/2=0

(2)求余操作符"%"

求余操作符"%"的运算量只能是整型。

如：5%2=1，而5.0%2是错误的。

(3)自加、自减操作符“++”、“--”
```c
//示例1
k = 5;
x = k++;
// 执行后，x = 5，k = 6
//示例2
k = 5;
x = ++k;
//执行后，x = 6，k = 6

//示例3
k = 5;
x = k--;
//执行后，x = 5，k = 4
//示例4
k = 5;
x = --k;
//执行后，x = 4，k = 4
```

* 原则6.3 必须了解编译系统的内存分配方式，特别是编译系统对不同类型的变量的内存分配规则，如局部变量在何处分配、静态变量在何处分配等。

* 原则6.4 不仅关注接口，同样要关注实现。

说明：这个原则看似和“面向接口”编程思想相悖，但是实现往往会影响接口，函数所能实现的功能，除了和调用者传递的参数相关，往往还受制于其他隐含约束，如：物理内存的限制，网络状况，具体看“抽象漏洞原则”。

* 规则6.1 禁止内存操作越界。

说明：内存操作主要是指对数组、指针、内存地址等的操作。内存操作越界是软件系统主要错误之一，后果往往非常严重，所以当我们进行这些操作时一定要仔细小心。

坚持下列措施可以避免内存越界：
* 1.数组的大小要考虑最大情况，避免数组分配空间不够。
* 2.避免使用危险函数sprintf /vsprintf/strcpy/strcat/gets操作字符串，使用相对安全的函数snprintf/strncpy/strncat/fgets代替。
* 3.使用memcpy/memset时一定要确保长度不要越界
* 4.字符串考虑最后的’\0’， 确保所有字符串是以’\0’结束
* 5.指针加减操作时，考虑指针类型长度
* 6.数组下标进行检查
* 7.使用时sizeof或者strlen计算结构/字符串长度，避免手工计算

* 规则6.2 禁止内存泄漏。

说明：内存和资源（包括定时器/文件句柄/Socket/队列/信号量/GUI等各种资源）泄漏是常见的错误。示例：异常出口处没有释放内存

```c
MsgDBDEV = (PDBDevMsg)GetBuff( sizeof( DBDevMsg ), __LINE__);
if (MsgDBDEV == NULL)
{
   return;
}
MsgDBAppToLogic = (LPDBSelfMsg)GetBuff( sizeof(DBSelfMsg), __LINE__ );
if ( MsgDBAppToLogic == NULL )
{
   return; //MsgDB_DEV指向的内存丢失
}
```

坚持下列措施可以避免内存泄漏：
* 1.异常出口处检查内存、定时器/文件句柄/Socket/队列/信号量/GUI等资源是否全部释放
* 2.删除结构指针时，必须从底层向上层顺序删除
* 3.使用指针数组时，确保在释放数组时，数组中的每个元素指针是否已经提前被释放了
* 4.避免重复分配内存
* 5.小心使用有return、break语句的宏，确保前面资源已经释放
* 6.检查队列中每个成员是否释放

* 规则6.3 禁止引用已经释放的内存空间。

说明：在实际编程过程中，稍不留心就会出现在一个模块中释放了某个内存块，而另一模块在随后的某个时刻又使用了它。要防止这种情况发生。

坚持下列措施可以避免引用已经释放的内存空间：

* 1.内存释放后，把指针置为NULL；使用内存指针前进行非空判断。
* 2.耦合度较强的模块互相调用时，一定要仔细考虑其调用关系，防止已经删除的对象被再次使用。
* 3. 避免操作已发送消息的内存。
* 4.自动存储对象的地址不应赋值给其他的在第一个对象已经停止存在后仍然保持的对象（具有更大作用域的对象或者静态对象或者从一个函数返回的对象）

* 规则6.4 编程时，**要防止差1错误。**

说明：此类错误一般是由于把“<=”误写成“<”或“>=”误写成“>”等造成的，由此引起的后果，很多情况下是很严重的，所以编程时，一定要在这些地方小心。当编完程序后，应对这些操作符进行彻底检查。使用变量时要注意其边界值的情况。

示例：如C语言中字符型变量，有效值范围为-128到127。故以下表达式的计算存在一定风险。
```c
char ch = 127;
int sum = 200;
ch += 1; // 127为ch的边界值，再加将使ch上溢到-128，而不是128
sum += ch; // 故sum的结果不是328，而是72。
```

* 规则6.5 所有的if ... else if结构应该由else子句结束 ；switch语句必须有default分支。

* 建议6.1 函数中分配的内存，在函数退出之前要释放。

说明：有很多函数申请内存，保存在数据结构中，要在申请处加上注释，说明在何处释放。

* 建议6.2 if语句尽量加上else分支，对没有else分支的语句要小心对待。

* 建议6.3 不要滥用goto语句。

* 说明：goto语句会破坏程序的结构性，所以除非确实需要，最好不使用goto语句。

可以利用goto语句方面退出多重循环；同一个函数体内部存在大量相同的逻辑但又不方便封装成函数的情况下，譬如反复执行文件操作，对文件操作失败以后的处理部分代码（譬如关闭文件句柄，释放动态申请的内存等等），一般会放在该函数体的最后部分，再需要的地方就goto到那里，这样代码反而变得清晰简洁。实际也可以封装成函数或者封装成宏，但是这么做会让代码变得没那么直接明了。

* 建议6.4 时刻注意表达式是否会上溢、下溢。
```c
示例：如下程序将造成变量下溢。
unsigned char size ;//只有正值
...
while (size-- >= 0) // 将出现下溢
{
... // program code
}
```

当size等于0时，再减不会小于0，而是0xFF，故程序是一个死循环。应如下修改。
```c
char size; // 从unsigned char 改为char
…
while (size-- >= 0)
{
... // program code
}
```


## 7.程序效率
* 原则7.1 在保证软件系统的正确性、简洁、可维护性、可靠性及可测性的前提下，提高代码效率。

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 
## 8.注释
* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 
## 9.排版与格式
* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 
## 10.表达式
* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

*
## 11.代码编辑、编译
* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

*

## 12.可测性
* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

*
## 13.安全性
* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

*
### 字符串操作安全
### 整数安全
### 格式化输出安全
### 文件I/O安全

## 14.单元测试

## 15.可移植性


## 16.业界编程规范






