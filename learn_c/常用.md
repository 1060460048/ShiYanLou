  # 常用

# 图片解码

```c
// jpage 解码库   libjpeg_turbo
#include "jpeglib.h"
/*
* 功能：解码jpeg图像到指定格式
* 参数：
*       injpeg     输入图像数据指针  可选
*       inLen      对应数据长度      可选
*       infile     输入图像文件指针
*       out        输出解码后的数据
*       outFormat  输出图形格式
*       imgWidth   获取到的 图像宽度
*       imgHeight  获取到的 图像高度
*/
int JPGdecode(char* injpeg, int inLen, FILE * infile, char* out, int outFormat, int *imgWidth, int *imgHeight)
{
	int ret = 0;
	int rowStride = 0;
	int ySize = 0;
	int uvSize = 0;
	char* yPtr = NULL;
	char* uPtr = NULL;
	char* vPtr = NULL;
	char* uvPtr = NULL;
	char *RowBuffer = NULL;

	struct jpeg_decompress_struct dinfo;// 此结构包含JPEG解压缩参数和指针 工作空间（根据JPEG库的需要分配）
	struct jpeg_error_mgr jerr;         // 我们使用我们的专用扩展名JPEG错误处理程序
	struct jpeg_source_mgr s_mgr(unsigned char *injpeg, int inLen);
	dinfo.err = jpeg_std_error(&jerr);          // 我们设置正常的JPEG错误例程
	jpeg_create_decompress(&dinfo);             // 1.初始化JPEG解压缩对象
	dinfo.src = &s_mgr;                         // 2.指定数据源（例如文件）
	//jpeg_stdio_src(&dinfo, infile);           // 输入jpeg图像文件指针模式

	int status = jpeg_read_header(&dinfo, TRUE);// 3.用jpeg_read_header（）读取文件参数
	if (status != JPEG_HEADER_OK)
	{
		printf("jpeg header corrupted");
		jpeg_destroy_decompress(&dinfo);
		return ret;
	}
	dinfo.out_color_space = JCS_YCbCr;          // 4. 设置解压缩参数   不设置默认为 rgb格式

	//dinfo.raw_data_out = true;
	// 放大缩小参数
    // dinfo.scale_num=4;   // 分子
	// dinfo.scale_denom=5; // 分母
	// 通过scale_num / scale_denom分数缩放图像。
	// 默认值是1 / 1，或不缩放。目前，唯一支持的缩放比率是M / 8，所有M从1到16，或其任何缩小比例（例如1 / 2，3 / 4等）

	status = jpeg_start_decompress(&dinfo);     // 5. 开始解码
	if (!status)
	{
		printf("jpeg_start_decompress failed");
		return ret;
	}
	*imgWidth  = dinfo.output_width;
	*imgHeight = dinfo.output_height;

	rowStride = dinfo.output_width * dinfo.output_components;//一行的数据长度
	RowBuffer = (char*)malloc(rowStride*sizeof(JSAMPLE));    // 行数据空间

	ySize = dinfo.output_width * dinfo.output_height;        // 一个通道数据量

	ret = ySize * 3 / 2;

	if (outFormat == 0) // HIK_PIXEL_FORMAT_NV21
	{
		yPtr = out;
		uvPtr = out + ySize;
		// 循环调用jpeg_read_scanlines来一行一行地获得解压的数据
		while (dinfo.output_scanline < dinfo.output_height)
		{
			(void)jpeg_read_scanlines(&dinfo, (JSAMPARRAY)&RowBuffer, 1);
			if (dinfo.output_scanline % 2 == 0)
			{
				YuvToNV21Line(RowBuffer, yPtr, uvPtr, dinfo.output_width, TRUE);
				uvPtr += dinfo.output_width;
			}
			else
			{
				YuvToNV21Line(RowBuffer, yPtr, uvPtr, dinfo.output_width, TRUE);
			}
			yPtr += dinfo.output_width;
		}

	}
	else if (outFormat == 1) // HIK_PIXEL_FORMAT_NV12
	{
		yPtr = out;
		uvPtr = out + ySize;
		while (dinfo.output_scanline < dinfo.output_height)
		{
			(void)jpeg_read_scanlines(&dinfo, (JSAMPARRAY)&RowBuffer, 1);
			if (dinfo.output_scanline % 2 == 0)
			{
				YuvToNV12Line(RowBuffer, yPtr, uvPtr, dinfo.output_width, TRUE);
				uvPtr += dinfo.output_width;
			}
			else
			{
				YuvToNV12Line(RowBuffer, yPtr, uvPtr, dinfo.output_width, TRUE);
			}
			yPtr += dinfo.output_width;
		}

	}
	else if (outFormat == 2)// HIK_PIXEL_FORMAT_YV12
	{
		yPtr = out;
		uPtr = out + ySize;
		vPtr = uPtr + (ySize / 4);
		while (dinfo.output_scanline < dinfo.output_height)
		{
			(void)jpeg_read_scanlines(&dinfo, (JSAMPARRAY)&RowBuffer, 1);
			if (dinfo.output_scanline % 2 == 0)
			{
				YuvToYV12Line(RowBuffer, yPtr, uPtr, vPtr, dinfo.output_width, TRUE);
				vPtr += (dinfo.output_width / 2);
				uPtr += (dinfo.output_width / 2);
			}
			else
			{
				YuvToYV12Line(RowBuffer, yPtr, uPtr, vPtr, dinfo.output_width, TRUE);
			}
			yPtr += dinfo.output_width;
		}
	}
	else
	{
		printf("unsupport format(%d)", outFormat);
	}

	jpeg_finish_decompress(&dinfo); // 7. 完成解压缩
	jpeg_destroy_decompress(&dinfo);// 8. 释放JPEG解压缩对象
	if (NULL != RowBuffer)
	{
		free(RowBuffer);
	}

	return ret;
}


```
