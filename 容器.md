# 顺序容器 内的元素按其位置存储和访问 (sequential container) vector deque  list forward_list  array  string
      vector        可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。
      
      deque	        双端队列。支持快速快速访问。在头尾位置插入/删除速度很快。
      
      list	        双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快。
      
      forward_list	单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快。
      
      array	        固定大小数组。支持快速随机访问，不能添加或删除元素。
      
      string	      与vector相似的容器，但专门用于保存字符。随机访问快，在尾部插入/删除都很快。
      
## 以下是一些选择容器的基本原则（具体视情况而定，这里只是一般情况）：
      1、通常vector是最好的选择，除非你有很好的理由选择其他容器；
      2、如果程序有很多小的元素，且空间额外开销很重要，则不要使用list或forward_list容器；
      3、如果程序要求随机访问，应使用vector或deque容器；
      4、如果程序要在头尾位置插入/删除，且不会在中间位置进行插入/删除操作，则应使用deque容器。



# 关联容器 按关键字保存和访问  map (key-value键值对，类似字典的概念) set(只包含一个关键字(关键字即值)) 
      #include <map>  
      #include <ext/hash_map>  
      #include <tr1/unordered_map>  
      using namespace std;  
      using namespace std::tr1;  
      //typedef map<int,int> MapKey;          //采用map  
      //typedef hash_map<int,int> MapKey;     //采用hash_map  
      typedef unordered_map<int,int> MapKey;  //采用unordered_map  
## 有序集合 RB树实现 红黑树
      map      关联数组：保存关键字-值对
      set      关键字即值,只保存关键字的容器
      multimap 关键字可重复出现的 map
      multiset 关键字可重复出现的 set 
## 无序集合  哈希函数实现
      unordered_map 哈希函数组织的map
      unordered_set 哈希函数组织的set
      unordered_multimap 哈希函数组织的multimap, 关键字可以重复出现
      unordered_multiset 哈希函数组织的multiset， 关键字可以重复出现
## 无序集合 基于hash table（哈希表）
      hash_map
      hash_set
      hash_multimap
      hash_multiset
      
## 结果分析
      运行效率方面：unordered_map最高，hash_map其次，而map效率最低
      占用内存方面：hash_map内存占用最低，unordered_map其次，而map占用最高
