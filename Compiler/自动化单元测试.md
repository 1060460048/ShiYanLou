# 自动化单元测试

## 1. 单元测试的一些原则：

1）测试用例能验证函数的正确性（这条都通不过就……）；

2）测试用例尽可能涵盖边界条件（例如遍历一个链表，头指针是空，只有一个节点，链表有N个节点，N是问题描述下允许的最大节点数等等）；

3）一些异常和错误处理（例如往一个函数里传入空指针，传入空串，这个函数能否打印一些log，返回错误码，实现加法的Add函数如何检测和处理溢出等等）



## 2. 打桩

**2.1什么是桩**

桩，或称桩代码，是指用来代替关联代码或者未实现代码的代码。如果函数func用func_stub来代替，那么，func称为原函数，func_stub称为桩函数。打桩就是编写或生成桩代码的过程。

**2.2打桩的目的主要有：**

> 1. 隔离

隔离是指将测试任务从产品项目中分离出来，使之能够独立编译、链接，并独立运行。

隔离的基本方法就是打桩，将测试任务之外的，并且与测试任务相关的代码，用桩来代替，从而实现分离测试任务。

例如函数func_a调用了函数func_b，函数func_b又调用了函数func_c和func_d，如果函数func_b用桩来代替，函数func_a就可以完全割断与函数func_c和func_d的关系。

> 2.补齐

补齐是指用桩来代替未实现的代码。

例如，函数func_a调用了函数func_b，而函数func_b由其他程序员编写，且未实现，那么，可以用桩来代替函数func_b，使函数func_a能够运行并测试。补齐在并行开发中很常用。

> 3.控制

控制是指在测试时，人为设定相关代码的行为，使之符合测试需求。

例如：
```c
extern int func_b();

int func_a()
{
      int ret = func_b();

      if(ret == 0)
           ;//do something
      else if(ret == 1)
           ;//do something
      else
           ;//do something

      return ret;
}

```

如果函数func_b返回随机数，或者返回网络状态，或者返回环境温度，等等，则当调用其实际代码时，函数func_a很难测试，这时可以用桩函数func_b_stub来代替func_b，使其返回测试所需要的数据。

一个桩函数，可能既具有控制功能，又具有隔离或补齐功能。


**3. 编写桩**

一般来说，桩函数原型要和原函数保持一致，仅仅是实现不同，这样测试代码才能正确链接到桩函数。用于实现隔离和补齐的桩函数一般比较简单，只需把原函数的声明拷过来，加一个空的实现，就能通过编译链接了。比较复杂的是实现控制功能的桩函数，要根据测试的需要，输出合适的数据，下面是一个示例：

```c
//获取环境温度。温度由出参pTemperature输出，返回值表示获取温度是否成功，如果成功，则返回1，否则返回0。

int GetTemperature(int* pTemperature)
{
      if(caseNameIs("failed"))
           return 0;
      if(caseNameIs("ok-23"))
      {
           *pTemperature = 23;
           return 1;
      }
      if(caseNameIs("ok-25"))
      {
           *pTemperature = 25;
           return 1;
      }
      if(caseNameIs("ok-28"))
      {
           *pTemperature = 28;
           return 1;
      }
      return 0;
}
```
其中，caseNameIs()是由测试工具提供的API，用于判断用例的名称。代码根据用例名称来决定输出数据。


**4. 动态打桩**

实际工作中，在我们编写单元测试代码时，需要在一个测试集合中，多次把原函数替换成桩函数进行测试，测试结束之后，又需要进行恢复。这就牵涉到动态打桩的概念了，我们先通过一个例子看一下动态打桩的效果。

```c
// stub_test.c : 定义控制台应用程序的入口点。
#include "stub.h"
#include <stdio.h>

void add(int i)
{
    printf("add(%d)\n",i);
}
 
void add_stub(int i)
{
    printf("add_stub(%d)\n",i);
}
 
int main()
{
    INSTALL_STUB(add,add_stub);
    add(12);
    REMOVE_STUB(add_stub);
    add(11);
    return 0;
}
```
上述代码编译运行结果为：
```c
add_stub(12)
add(11)
```

通过结果可以明显看出，在执行INSTALL_STUB(add,add_stub)之后，原函数add已经被动态替换成了add_stub桩函数，在执行REMOVE_STUB(add_stub)之后，原函数add又恢复正常调用了。


**5. 桩（stub）和模拟（mock）的区别**

mock框架可以非常容易的开发stub和mock，但是stub框架想要提高mock机制就要靠自己扩展了。

两者主要的区别如下：

1. stub存在的意图是为了让测试对象可以正常的执行，其实现一般会硬编码一些输入和输出。

2. mock除了保证stub的功能之外，还可深入的模拟对象之间的交互方式，如：调用了几次、在某种情况下是否会抛出异常。


