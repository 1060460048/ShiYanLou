# c++11新特性

[参考](https://www.cnblogs.com/feng-sc/p/5710724.html)

[C++11系列-什么是C++11](http://towriting.com/blog/2013/08/01/what-is-cpp11/)

# 目录

    1、关键字及新语法
      1.1、auto 关键字及用法
      1.2、nullptr 关键字及用法
      1.3、for 循环语法
    2、STL容器
      2.1、std::array
      2.2、std::forward_list
      2.3、std::unordered_map
      2.4、std::unordered_set
    3、多线程
      3.1、std::thread
      3.2、st::atomic
      3.3、std::condition_variable
    4、智能指针内存管理
      4.1、std::shared_ptr
      4.2、std::weak_ptr
    5、其他
      5.1、std::function、std::bind封装可执行对象
      5.2、lamda表达式
      
# 1、关键字及新语法
## 1.1、auto关键字及用法
　　A、auto关键字能做什么？ 编译器根据上下文情况，确定auto变量的真正类型。
```c
auto AddTest(int a, int b) 
{
    return a + b;
}

int main()
{
    auto index = 10;
    auto str = "abc";
    auto ret = AddTest(1,2);
    std::cout << "index:" << index << std::endl;
    std::cout << "str:" << str << std::endl;
    std::cout << "res:" << ret << std::endl;
}
// auto在C++14中可以作为函数的返回值
```

     B、auto作为函数返回值时，只能用于定义函数，不能用于声明函数。
```c
// 声明函数
#pragma once
class Test
{
public:
    auto TestWork(int a ,int b);
};
// 定义函数
#pragma once
class Test
{
public:
    auto TestWork(int a, int b)
    {
        return a + b;
    }
};
```
## 1.2、nullptr关键字及用法
```c
class Test
{
public:
    void TestWork(int index)
    {
        std::cout << "TestWork 1" << std::endl;
    }
    void TestWork(int * index)
    {
        std::cout << "TestWork 2" << std::endl;
    }
};

int main()
{
    Test test;
    test.TestWork(NULL);    // NULL被翻译成0       >>> TestWork 1
    test.TestWork(nullptr); // nullptr确定为 指针  >>> TestWork 2
}
```

## 1.3 范围for 配合auto

```c
int main()
{
    int numbers[] = { 1,2,3,4,5 };
    std::cout << "numbers:" << std::endl;
    for (auto number : numbers)
    {
        std::cout << number << std::endl;
    }
}
```
# 2、STL容器
## 2.1、std::array 跟数组并没有太大区别  增加了迭代器等函数
```c
#include <array>
int main()
{
    std::array<int, 4> arrayDemo = { 1,2,3,4 };
    std::cout << "arrayDemo:" << std::endl;
    for (auto itor : arrayDemo)
    {
        std::cout << itor << std::endl;
    }
    int arrayDemoSize = sizeof(arrayDemo);
    std::cout << "arrayDemo size:" << arrayDemoSize << std::endl; // 4*4 =16
    return 0;
}

```

## 2.2、std::forward_list 新增的线性表，与list区别在于它是单向链表
    链表在对数据进行插入和删除是比顺序存储的线性表有优势，
    因此在插入和删除操作频繁的应用场景中，
    使用list和forward_list比使用array、vector和deque效率要高很多。
```C
#include <forward_list>
int main()
{
    std::forward_list<int> numbers = {1,2,3,4,5,4,4};
    std::cout << "numbers:" << std::endl;
    for (auto number : numbers)
    {
        std::cout << number << std::endl;
    }
    numbers.remove(4);
    std::cout << "numbers after remove:" << std::endl;
    for (auto number : numbers)
    {
        std::cout << number << std::endl;
    }
    return 0;
}

```
## 2.3、std::unordered_map  哈希map 无序map 
　　  std::unordered_map与std::map用法基本差不多，但STL在内部实现上有很大不同，
      std::map使用的数据结构为二叉树，
      而std::unordered_map内部是哈希表的实现方式，哈希map理论上查找效率为O(1)。
      但在存储效率上，哈希map需要增加哈希表的内存开销。
      
```c
#include <iostream>
#include <string>
#include <unordered_map>
int main()
{
    std::unordered_map<std::string, std::string> mymap =
    {
        { "house","maison" },
        { "apple","pomme" },
        { "tree","arbre" },
        { "book","livre" },
        { "door","porte" },
        { "grapefruit","pamplemousse" }
    };
    unsigned n = mymap.bucket_count();// 使用的内存桶数量
    std::cout << "mymap has " << n << " buckets.\n";
    for (unsigned i = 0; i<n; ++i)    // 遍历每一个桶，每个桶内可能存在多个数据 
    {
        std::cout << "bucket #" << i << " contains: ";
        for (auto it = mymap.begin(i); it != mymap.end(i); ++it)// 遍历每个桶内存储的数据
            std::cout << "[" << it->first << ":" << it->second << "] ";
        std::cout << "\n";
    }
    return 0;
}

```
## 2.4、std::unordered_set  无序集合
　　  std::unordered_set的数据存储结构也是哈希表的方式结构，
      除此之外，std::unordered_set在插入时不会自动排序，这都是std::set表现不同的地方。
```C
#include <iostream>
#include <string>
#include <unordered_set>
#include <set>
int main()
{
    std::unordered_set<int> unorder_set;
    unorder_set.insert(7);
    unorder_set.insert(5);
    unorder_set.insert(3);
    unorder_set.insert(4);
    unorder_set.insert(6);
    std::cout << "unorder_set:" << std::endl;
    for (auto itor : unorder_set)
    {
        std::cout << itor << std::endl; // 无序,不会排序，按插入的循序打印 7,5,3,4,6
    }

    std::set<int> set; // 有序，在插入时会自动排序
    set.insert(7);
    set.insert(5);
    set.insert(3);
    set.insert(4);
    set.insert(6);
    std::cout << "set:" << std::endl;
    for (auto itor : set)
    {
        std::cout << itor << std::endl;// 有序3,4,5,6,7
    }
}

```

# 3、多线程
    C++11中，引入了boost库中的多线程部分内容，形成C++标准，
    形成标准后的boost多线程编程部分接口基本没有变化，
    这样方便了以前使用boost接口开发的使用者切换使用C++标准接口，
    把容易把boost接口升级为C++接口。
    
## 3.1、std::thread
    std::thread为C++11的线程类，使用方法和boost接口一样，非常方便，
    同时，C++11的std::thread解决了boost::thread中构成参数限制的问题。
```c
#include <thread>
void threadfun1()
{
    std::cout << "threadfun1 - 1\r\n" << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(1));// 本线程休息1s
    std::cout << "threadfun1 - 2" << std::endl;
}

void threadfun2(int iParam, std::string sParam)
{
    std::cout << "threadfun2 - 1" << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(5));// 本线程休息5s
    std::cout << "threadfun2 - 2" << std::endl;
}

int main()
{
    std::thread t1(threadfun1);// 线程绑定 需要执行的函数  打印 threadfun1 - 1
    std::thread t2(threadfun2, 10, "abc");           //  打印 threadfun2 - 1
    
    t1.join();// t1.join()会等待t1线程退出后才继续往下执行
                                                     //  打印 threadfun1 - 2
                                                     //  往下执行
    
    
    
    std::cout << "join" << std::endl;
    t2.detach();                // 执行的线程从线程对象中被分离，已不再被一个线程对象所表达,可以
    std::cout << "detach" << std::endl; // threadfun2 - 2 没有输出
    // detach字符输出后，主函数退出，threadfun2还未执行完成，但是在主线程退出后，t2的线程也被已经被强退出
}


```
    
    



      
      

