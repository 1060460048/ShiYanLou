# cpp程序优化
[C++编程优化——让你的代码飞起来 RGB格式的彩色图像先转换成黑白图像](http://blog.chinaunix.net/uid-20806919-id-132246.html)

[C/C++代码优化具体方案 ](https://blog.csdn.net/jinzhichaoshuiping/article/details/53400595)

## c++ 性能优化策略

    1.关于继承：尽量少使用多重继承
        不可否认良好的抽象设计可以让程序更清晰，代码更看起来更好，但是她也是有损失的，在继承体系中子类的创建会调用父类的构造函数，
        销毁时会调用父类的析构函数，这种消耗会随着继承的深度直线上升，所以不要过度的抽象和继承，
        更为严重的是当多重继承中并且有虚函数的存在时情况更为复杂，的确，这些问题涉及开销，但是多重继承减少了编码的负担，
        同时也让问题的解决方案更加简洁，这当然要付出一些代价。总之,与n个基类的多重继承层次相关的额外虚函数表有n-1个。
        派生类和最左边的非虚基类共享同一个虚函数表。因此,带有2个基类的多重继承层次,
        有1个(2-1=1)基类的虚函数表和1个派生类的虚函数表(最左边的基类与派生类共享该虚函数表),
        总共有2个虚函数表，如果有虚继承的存在，会进一步增长这个过程，它是有额外的开销的。

    2.对象的复合：
        对象的复合和继承很相似，当一个对象包含其他对象构造时也会引起额外的构造。
        关于这点可能会有很多人不解，认为这是不可避免的，举个例子，比如你的类A中包含了类B非指针和引用对象，
        那么在你构造对象a的时候会自动调用b的无参构造函数，即使你还没有用到她，用指针代替就没有这种消耗，
        另外如果你的一个对象中用到数组和字符串，你是选择string和vector还是char* 和 c系的数组呢，
        如果没有用到c++stl库提供的相关的高级用法，建议选择后者。

    3.构造函数：
        尽量用 参数列表 初始化 代替 参数，避免值传递初始化。

    4.变量延时定义：
        从c系转过来的仍保留着c的习惯，在函数第一行先把所有用到的变量都定义好，
        但是c是没有运行时的消耗的，对于c++时不一样的，对于c++对象的构造和销毁时有消耗的，
        如果有大量的对象只在某个if条件的一个分支中出现，那就会有50%的情况这些消耗是可以避免的。
        对于这点在一个类中也是一样的，如果成员中有成员只在某个时刻能用，就用指针代替，
        在构造对象时初始化成空指针，避免构造时调用他的构造函数。

    5.虚函数：
        虚函数的底层实现是通过一个 虚函数表 来实现的，因此有虚函数的类构造时必须先初始化虚函数表，
        函数调用时也必须先找到虚函数表，然后通过指针偏移找到相应的函数，通常情况下调用虚函数是没有运行时消耗的，
        但是根据编译器的实现不同,在调用虚函数时,有些调用可能导致增加虚函数表大小的额外开销,
        或者只有那些需要调整 this指针 的调用才会发生额外的运行开销,但不会增加虚函数表的大小，
        在多重继承 和 虚基类的时候这种消耗会显著增加，关于继承已经提过，所以避免滥用虚函数和虚继承，
        有时候可以用模版设计来代替虚继承，把运行时的消耗提前到编译期。

[虚函数表](https://github.com/Ewenwan/ShiYanLou/tree/master/learn_cpp#c虚函数技术)

    6.返回值优化： 
      虽然c++编译器会选择性的进行 RVO(return value optimization) 优化，
      但是不是强制的，当函数有多个返回语句并且返回不通名称的对象，
      函数过于复杂，返回对象没有定义拷贝构造函数时，rvo优化是不会执行的，
      所以当函数返回一个很大的对象时在不确定rvo优化会执行时，尽量避免值传递。

    7.变量的定义：在定义变量时 尽量避免 类型的不匹配 造成临时变量的产生。

    8.内存管理：内存池
      c++内存管理的大权由我们自己掌握，对于项目中要 频繁申请和释放的对象 建议用简单的内存池来管理，
      可以大大的降低频繁申请和释放内存带来的消耗。

    9.善用内联：
      内联函数不仅仅是简单的函数调用似的优化，他还有一个最大的优点就是，
      可以让编译期进行进行边界代码的运行环境优化，
      内联把代码拷贝到执行环境处避免了函数调用带来的消耗，
      并且编译期可以进行正常的编译优化，而函数调用是不能实现的。

    10.stl ：
      记住一点stl不是唯一的选择，有时候也不是最好的选择，合理选择stl善用stl算法。


    11 缓存：对于多次使用的计算结果及时缓存，避免重复计算。

    12 延时计算：对于不关心计算结果的计算过程尽量延时执行或者异步去执行。

    13 多线程：无锁化编程
       尽可能的使用无锁式多线程开发，锁是一个非常消耗性能的东西，
       保证数据同步的手段有很多，voalite，原子操作都可已实现，
       尽量通过一些技巧使用这些手段避免锁 的使用，如果迫不得已要使用锁，
       尽量减少锁的消耗，比如降低锁的粒度，使用性能更高的锁等等。
       
[线程池 实现代码](https://github.com/progschj/ThreadPool)

[算法优化之c++多线程优化：思考与总结](https://blog.csdn.net/gaussrieman123/article/details/80981144)

    14 std::move操作: 
       当不得不进行 深拷贝时，如果 深拷贝数据源 在拷贝后就不在使用，尽可能的用move操作代替，
       或者在参数传递时 用move操作代替 临时的 实参变量。

    15 cpu缓存：合理的利用cpu cache缓存 可以极大的提高代码的运行效率(
       例如：数组中以 每列遍历 和 每行遍历的效率的不同)， 
       当然多线程环境下也要考虑cpu cache带来的影响。

    16 内存对齐：
       在进行网络编程时，最好对网络中传送的数据快进行内存补齐，
       通常是8字节对其，提高cpu访问内存效率，从而提高数据读写速度。

    17 函数参数：
       用const引用 代替 值传递，如果函数参数过多，
       可以用对象 来 打包参数，减少参数过多带来的性能消耗。

    18 算法: 尽可能的优化你的算法。

    19 关于智能指针：必须用
       对于智能指针我的选择是 必须用，它可以大大降低程序的crash频率，
       但是智能指针的和普通指针相比是有额外的消耗的，
       她的底层是一个 原子操作 来 统计引用数 和 一个普通指针，
       虽然原子操作和锁相比性能高了不少但是和普通的加减操作还是慢了不少，
       智能指针 的大小为16个字节，而 普通指针 的大小只有4个字节，
       拷贝的成本也不一样，所以在使用正确的情况下可以使用 智能指针的引用 来减少拷贝的消耗（
       注意这里的前提是正确的使用引用，不要引用以一个即将被销毁的变量）。

    20 内存池:
       对于需要 频繁申请和释放 的内存对象,如果可以重复利用对象的内存，
       强烈建议通过 内存池 或者 重载对象的 new操作符 或者 重载对象的 placement new操作符 
       来减少频繁的申请和释放内存，从而减少申请和释放内存的消耗和内存碎片的产生。

    21 其他优化方案：位运算代替乘除法，前缀运算符代替后缀运算等等。




## 什么是并行优化？
    并行优化是代码优化的基本方法，从大到小一共可以分成三级：
       异步框架；任务并行；数据并行。
    在实际工作中，
    第一步一般是先设计 异步框架，包括 异步处理任务 以及 异步任务 的 异构化 等；
    第二步一般是做     数据并行优化(SIMD)，利用CPU的 向量指令 来对 多条数据并行处理；
    这两步是 代码 优化的重心，一般做完这两步，系统性能会有明显的提升。
    
    今天要讨论的是第三步，for循环的并行优化。
    与前两者不同的是，for循环往往是处理同一类任务，且通常会涉及到对同一个变量的读写，
    所以异步是不能用，而且for循环中往往包含 多种结构 比如 逻辑判断 和 算术过程等，
    所以通常也很 难用数据并行的方式来优化，那么怎么对for循环进行优化呢？
```c
// 例1 内存操作,申请一段内存空间然后释放
void testfuc(int num){
    int a = 0;
    for (int i = 0; i != num; i++) {
        int *b = new int[10]();
        delete [] b;
    }
```
    假设num = 1e7；一千万次内存操作在我的机器上(2.6 GHz Intel Core i5双核)运行耗时在900ms左右。
    为了对这个for循环进行优化，首先将for循环拆分成若干部分，比如两部分：
    
```c    
void testfuc(int num){
    int a = 0;
    int num2 = num >> 1;
    // 前半部分
    for (int i = 0; i != num2; i++) {
        int *b = new int[10]();
        delete [] b;
    }
    // 后半部分
    for (int i = num2; i != num; i++) {
        int *b = new int[10]();
        delete [] b;
    }
}
```
    然后使用c11的 future + async来启动两个异步任务分别处理一个子循环：
```c
// https://blog.csdn.net/u011726005/article/details/78266706
//--------------------------------------------------------------------------------
// 3.std::future可以用来获取异步任务的结果，因此可以把它当成一种简单的线程间同步的手段。
// std::future通常由某个Provider创建，你可以把Provider想象成一个异步任务的提供者，
// Provider在某个线程中设置共享状态的值，与该共享状态相关联的std::future对象调用get（通常在另外一个线程中获取该值，
// 如果共享状态的标志不为ready，则调用std::future::get会阻塞当前的调用者，直到Provider设置了共享状态的值
//（此时共享状态的标志变为ready），std::future::get返回异步任务的值或异常（如果发生了异常）。
 
// 一个有效的std::future 对象通常由以下三种 Provider 创建，并和某个共享状态相关联,分别是
// std::async 函数,std::promise::get_future。std::packaged_task::get_future。
 
// 在一个有效的 future 对象上调用get会阻塞当前的调用者，直到Provider设置了共享状态的值或异常。
 
// 4.c++11还提供了异步接口std::async，通过这个异步接口可以很方便的获取线程函数的执行结果。
// std::async会自动创建一个线程去调用线程函数，它返回一个std::future，这个future中存储了线程函数返回的结果，
// 当我们需要线程函数的结果时，直接从future中获取。

void testfuc2(int num){
    int a = 0;
    int num2 = num/2;
    future<void> ft1 = async(std::launch::async, [&]{ // 封装为lambda函数 后传入
        for (int i = 0; i != num2; i++) {
            int *b = new int[10]();
            delete [] b;
        }
    });
    
    future<void> ft2 = async(std::launch::async, [&]{ // 封装为lambda函数 后传入
        for (int i = num2; i != num; i++) {
            int *b = new int[10]();
            delete [] b;
        }
    });
    
    ft1.wait();
    ft2.wait();
}

```
    将testfunc1和testfunc2放在一起测试，运行结果如下：
      time1 = 992.360000
      time2 = 475.182000
    
    
    显然testfunc2要明显比testfunc1快，在本次运行结果中，时间少了一半，
    但是这个时间不一定每次都是一半，由于线程切换和CPU状态的影响，
    testfunc2的时间会比testfunc1节省40%-50%。
   
```c
// 复杂计算 优化后函数为：

void testfuc2(int num){
    int num2 = num/2;
    future<void> ft1 = async(std::launch::async, [&]{
        for (int i = 0; i != num2; i++) {
            b = cos(tan(i));
        }
    });
    
    future<void> ft2 = async(std::launch::async, [&]{
        for (int j = num2; j != num; j++) {
            c = cos(tan(j));
        }
    });
    
    ft1.wait();
    ft2.wait();
}

```
    运行结果为：

    time1 = 806.438000
    time2 = 407.875000 


## 嵌入式C/C++代码优化
    1.引言
        计算机技术和信息技术的高速发展的今天，计算机和计算机技术大量应用在人们的日常生活中，
        嵌入式计算机也得到了广泛的应用。 
        嵌入式计算机是指完成一种或多种特定功能的计算机系统，是软硬件的紧密结合体。
        具有软件代码小、高度自动化、响应速度快等特点。
        特别适合于要求实时和多任务的应用体系。嵌入式实时系统是目前蓬勃发展的行业之一。 
        但是，实时嵌入式系统的特点使得其软件受时间和空间的严格限制，
        加上运行环境复杂，使得嵌入式系统软件的开发变得异常困难。 
        为了设计一个满足功能、性能和死线要求的系统，
        为了开发出安全可靠的高性能嵌入式系统，开发语言的选择十分重要。

    2.嵌入式实时程序设计中语言的选择
        随着嵌入式系统应用范围的不断扩大和 
        嵌入式实时操作系统RTOS(Real Time Operating System)的广泛使用，
        高级语言编程已是嵌入式系统设计的必然趋势。
        因为汇编语言和 具体的微处理器 的硬件结构密切相关，移植性较差，既不宜在复杂系统中使用，又不便于实现软件重用；
        而高级语言具有良好的通用性和丰富的软件支持，便于推广、易于维护，因此高级语言编程具有许多优势。
        目前，在嵌入式系统开发过程中使用的语言种类很多，但仅有少数几种语言得到了比较广泛的应用。
        其中C和C++是应用最广泛的。C++ 在支持现代软件工程、 OOP(Object Oriented Programming，面向对象的程序设计)、
        结构化等方面对C进行了卓有成效的改进，但在程序代码容量、执行速度、 程序复杂程度等方面比C语言程序性能差一些。
        由于C语言既有低级语言的直接控制硬件的能力，又有高级语言的灵活性，是目前在嵌入式系统中应用最广泛的编程语言。
        随着网络技术和嵌入式技术的不断发展，Java的应用也得到广泛应用。

    3.C/C++代码在实时程序设计中的优化
        虽然使软件正确是一个工程合乎逻辑的最后一个步骤，但是在嵌入式的系统开发中，情况并不总是这样的。
        出于对低价产品的需求， 硬件的设计者需要提供刚好足够的存储器和完成工作的处理能力。
        所以在嵌入式软件设计的最后一个阶段则变成了对代码的优化。

        现代的C和C++编译器都提供了一定程度上的代码优化。
        然而，大部分由编译器执行的优化仅 涉及执行速度和代码大小 的一个平衡。
        你的程序能够变得更快或者更小，但是不可能又变快又变小。
        经过本人在嵌入式系统设计和实现过程中实践，下面介绍几种简单且行之有效的C/C++代码的优化方法。

    1) Inline函数
        在C++中，关键字Inline 可以被加入到任何函数的声明中。
        这个关键字 请求编译器用 函数内部的代码替换所有对于指出的函数的调用。 
        这样做在两个方面快于函数调用。这样做在两个方面快于函数调用：
        第一，省去了调用指令需要的执行时间；
        第二，省去了传递变元 和 传递过程需要的时间。
        但是使用这种方法在优化程序速度的同时，程序长度变大了，因此需要更多的ROM。
        使用这种优化在Inline函数频繁调用并且只包含几行代码的时候是最有效的。

    2)用指针 代替 数组
        在许多种情况下，可以用指针运算 代替数组索引，这样做常常能产生又快又短的代码。
        与数组索引相比，指针一般能使代码速度更快，占用空间更少。
        使用多维数组时差异更明显。
        下面的代码作用是相同的，但是效率不一样。 
    
    数组索引 指针运算 
```c
for(;;)
    { 
    p=array 
    A=array[t++];
    for(;;)
    { 
        a=*(p++); 
        ...... ...... 
    } 
}
```

    指针方法的优点是，array的地址每次装入地址p后，在每次循环中只需对p增量操作。
    在数组索引方法中，每次循环中都必须进行基于t值求数组下标的复杂运算。

    3)不定义 不使用的返回值
        function函数定义 并不知道函数 返回值是否被使用，
        假如返回值从来不会被用到，
        应该使用void来明确声明函数不返回任何值。

    4)手动编写汇编
        在嵌入式软件开发中，一些软件模块最好用汇编语言来写，这可以使程序更加有效。
        虽然C/C++编译器对代码进行了优化，但是适当的 使用 内联汇编指令 可以有效的提高整个系统运行的效率。

    5)使用寄存器变量
        在声明 局部变量 的时候可以使用 register关键字。
        这就使得编译器把变量放入一个多用途的寄存器中，而不是在堆栈中，
        合理使用这种方法可以提高执行速度。
        函数调用越是频繁，越是可能提高代码的速度。

    6)使用增量和减量操作符
        在使用到加一和减一操作时尽量使用增量和减量操作符，因为增量符语句比赋值语句更快，
        原因在于对大多数CPU来说，对内存字的增、 减量操作不必明显地使用取内存和写内存的指令，
        比如下面这条语句： 
    x=x+1; 
    模仿大多数微机汇编语言为例，产生的代码类似于：

```asm
move A,x ;把x从内存取出存入累加器A 
add A,1 ;累加器A加1 
store x ;把新值存回x
```

    如果使用增量操作符，生成的代码如下： 
    incr x ; x加1 
    显然，不用取指令和存指令，增、减量操作执行的速度加快，同时长度也缩短了。

    7)减少函数调用参数  
        使用全局变量比函数传递参数更加有效率。
        这样做去除了函数调用参数入栈和函数完成后参数出栈所需要的时间。
        然而决定使用全局变量会影响程序的模块化和重入，故要慎重使用。

    8)Switch语句中 根据 发生频率 来 进行case排序

    switch语句是一个普通的编程技术，编译器会产生if-else-if的嵌套代码，
    并按照顺序进行比较，发现匹配时，就跳转到满足条件的语句执行。
    使用时需要注意。每一个由机器语言实现的测试和跳转仅仅是为了决定下一步要做什么，就把宝贵的处理器时间耗尽。
    为了提高速度，没法把具体的情况按照它们发生的相对频率排序。
    换句话说，把最可能发生的情况放在第一位，最不可能的情况放在最后。

    9)将大的switch语句转为嵌套switch语句
        当switch语句中的case标号很多时，为了减少比较的次数，明智的做法是把大switch语句转为嵌套switch语句。
        把发生频率高的case 标号放在一个switch语句中，并且是嵌套switch语句的最外层，
        发生相对频率相对低的case标号放在另一个switch语句中。
        比如，下面的程序段把相对发生频率低的情况放在缺省的case标号内。 
```c    
pMsg=ReceiveMessage();

switch (pMsg->type) 
{ 
    case FREQUENT_MSG1: 
    handleFrequentMsg(); 
    break; 
    
    case FREQUENT_MSG2: 
    handleFrequentMsg2(); 
    break; 
    
    ...
    
    case FREQUENT_MSGn: 
    handleFrequentMsgn(); 
    break; 
    
    default: //嵌套部分用来处理不经常发生的消息 ====
    switch (pMsg->type) 
    { 
        case INFREQUENT_MSG1: 
        handleInfrequentMsg1(); 
        break; 
        
        case INFREQUENT_MSG2: 
        handleInfrequentMsg2(); 
        break; 
        
        ......
        
        case INFREQUENT_MSGm: 
        handleInfrequentMsgm(); 
        break; 
    } 
} 

```
    如果switch中每一种情况下都有很多的工作要做，
    那么把整个switch语句用一个指向函数指针的表 来替换会更加有效，
    比如下面的switch语句，有三种情况： 
```c
enum MsgType{Msg1, Msg2, Msg3} 
switch (ReceiveMessage() 
{ 
case Msg1; 
...... 
case Msg2; 
..... 
case Msg3; 
..... 
}
```

为了提高执行速度，用下面这段代码来替换这个上面的switch语句。
```c
/*准备工作*/ 
int handleMsg1(void); 
int handleMsg2(void); 
int handleMsg3(void); 
/*创建一个函数指针数组*/ 
int (*MsgFunction [])()={handleMsg1, handleMsg2, handleMsg3};//函数指针数组 
/*用下面这行更有效的代码来替换switch语句*/

status=MsgFunction[ReceiveMessage()]();
```

    10)避免使用C++的昂贵特性
        C++在支持现代软件工程、OOP、结构化等方面对C进行了卓有成效的改进，
        但在程序代码容量、执行速度、程序复杂程度等方面比C语言程序性能差一些。
        并不是所有的C++特性都是肮贵的。
        比如，类的定义是完全有益的。
        公有和私有成员数据及函数的列表与一个 struct 及函数原形的列表并没有多大的差别。
        单纯的加入类既不会影响代码的大小，也不会影响程序的效率。

        但C++的多重继承、虚拟基类、模板、 异常处理及运行类型识别等特性对代码的大小和效率有负面的影响，
        因此对于C++的一些特性要慎重使用，可做些实验看看它们对应用程序的影响。

    4 总结语
        在嵌入式实时程序设计时可以运用上面介绍的一种或多种技术来优化代码。
        上面介绍的方法主要是为了提高代码的效率。
        但是事实上，在使用这些技术提高代码运行速度的同时会相应的产生一些负面的影响，
        比如增加代码的大小、降低程序可读性等。
        不过你可以让C/C++编 译器来进行减少代码大小的优化，而手动利用以上技术来减少代码的执行时间。
        在嵌入式程序设计中合理地使用这几种技术有时会达到很好 的优化效果。

## C/C++代码优化具体方案
[C/C++代码优化具体方案 ](https://blog.csdn.net/jinzhichaoshuiping/article/details/53400595) 





